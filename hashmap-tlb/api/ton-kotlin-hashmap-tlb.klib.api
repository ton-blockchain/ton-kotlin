// Klib ABI Dump
// Targets: [iosArm64, iosSimulatorArm64, iosX64, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, watchosArm32, watchosArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <org.ton.kotlin:ton-kotlin-hashmap-tlb>
abstract interface <#A: kotlin/Any?, #B: kotlin/Any?> org.ton.hashmap/AugmentedDictionary : kotlin.collections/Iterable<kotlin/Pair<org.ton.bitstring/BitString, org.ton.hashmap/AugmentedDictionary.Node<#A, #B>>> { // org.ton.hashmap/AugmentedDictionary|null[0]
    abstract fun get(org.ton.bitstring/BitString): org.ton.hashmap/AugmentedDictionary.Leaf<#A, #B>? // org.ton.hashmap/AugmentedDictionary.get|get(org.ton.bitstring.BitString){}[0]

    abstract interface <#A1: kotlin/Any?, #B1: kotlin/Any?> Leaf : org.ton.hashmap/AugmentedDictionary.Node<#A1, #B1> { // org.ton.hashmap/AugmentedDictionary.Leaf|null[0]
        abstract val extra // org.ton.hashmap/AugmentedDictionary.Leaf.extra|{}extra[0]
            abstract fun <get-extra>(): #B1 // org.ton.hashmap/AugmentedDictionary.Leaf.extra.<get-extra>|<get-extra>(){}[0]
        abstract val value // org.ton.hashmap/AugmentedDictionary.Leaf.value|{}value[0]
            abstract fun <get-value>(): #A1 // org.ton.hashmap/AugmentedDictionary.Leaf.value.<get-value>|<get-value>(){}[0]
    }

    abstract interface <#A1: kotlin/Any?, #B1: kotlin/Any?> Node { // org.ton.hashmap/AugmentedDictionary.Node|null[0]
        abstract val extra // org.ton.hashmap/AugmentedDictionary.Node.extra|{}extra[0]
            abstract fun <get-extra>(): #B1 // org.ton.hashmap/AugmentedDictionary.Node.extra.<get-extra>|<get-extra>(){}[0]
        abstract val value // org.ton.hashmap/AugmentedDictionary.Node.value|{}value[0]
            abstract fun <get-value>(): #A1? // org.ton.hashmap/AugmentedDictionary.Node.value.<get-value>|<get-value>(){}[0]
    }
}

abstract interface <#A: kotlin/Any?, #B: kotlin/Any?> org.ton.hashmap/HashmapAug : org.ton.hashmap/AugmentedDictionary<#A, #B>, org.ton.tlb/TlbObject { // org.ton.hashmap/HashmapAug|null[0]
    abstract val n // org.ton.hashmap/HashmapAug.n|{}n[0]
        abstract fun <get-n>(): kotlin/Int // org.ton.hashmap/HashmapAug.n.<get-n>|<get-n>(){}[0]

    abstract fun get(org.ton.bitstring/BitString): org.ton.hashmap/HashmapAugNode.AhmnLeaf<#A, #B>? // org.ton.hashmap/HashmapAug.get|get(org.ton.bitstring.BitString){}[0]
    abstract fun iterator(): kotlin.collections/Iterator<kotlin/Pair<org.ton.bitstring/BitString, org.ton.hashmap/HashmapAugNode<#A, #B>>> // org.ton.hashmap/HashmapAug.iterator|iterator(){}[0]

    abstract interface <#A1: kotlin/Any?, #B1: kotlin/Any?> AhmEdge : org.ton.hashmap/HashmapAug<#A1, #B1> { // org.ton.hashmap/HashmapAug.AhmEdge|null[0]
        abstract val label // org.ton.hashmap/HashmapAug.AhmEdge.label|{}label[0]
            abstract fun <get-label>(): org.ton.hashmap/HmLabel // org.ton.hashmap/HashmapAug.AhmEdge.label.<get-label>|<get-label>(){}[0]
        abstract val n // org.ton.hashmap/HashmapAug.AhmEdge.n|{}n[0]
            abstract fun <get-n>(): kotlin/Int // org.ton.hashmap/HashmapAug.AhmEdge.n.<get-n>|<get-n>(){}[0]
        abstract val node // org.ton.hashmap/HashmapAug.AhmEdge.node|{}node[0]
            abstract fun <get-node>(): org.ton.hashmap/HashmapAugNode<#A1, #B1> // org.ton.hashmap/HashmapAug.AhmEdge.node.<get-node>|<get-node>(){}[0]

        open fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HashmapAug.AhmEdge.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]

        final object Companion { // org.ton.hashmap/HashmapAug.AhmEdge.Companion|null[0]
            final fun <#A3: kotlin/Any?, #B3: kotlin/Any?> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#A3>, org.ton.tlb/TlbCodec<#B3>): org.ton.tlb/TlbCodec<org.ton.hashmap/HashmapAug.AhmEdge<#A3, #B3>> // org.ton.hashmap/HashmapAug.AhmEdge.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:0>;org.ton.tlb.TlbCodec<0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        }
    }

    final object Companion { // org.ton.hashmap/HashmapAug.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> edge(kotlin/Int, org.ton.hashmap/HashmapAugNode<#A2, #B2>): org.ton.hashmap/HashmapAug.AhmEdge<#A2, #B2> // org.ton.hashmap/HashmapAug.Companion.edge|edge(kotlin.Int;org.ton.hashmap.HashmapAugNode<0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> edge(kotlin/Int, org.ton.hashmap/HmLabel, org.ton.hashmap/HashmapAugNode<#A2, #B2>): org.ton.hashmap/HashmapAug.AhmEdge<#A2, #B2> // org.ton.hashmap/HashmapAug.Companion.edge|edge(kotlin.Int;org.ton.hashmap.HmLabel;org.ton.hashmap.HashmapAugNode<0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#A2>, org.ton.tlb/TlbCodec<#B2>): org.ton.tlb/TlbCodec<org.ton.hashmap/HashmapAug<#A2, #B2>> // org.ton.hashmap/HashmapAug.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:0>;org.ton.tlb.TlbCodec<0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    }
}

abstract interface <#A: kotlin/Any?, #B: kotlin/Any?> org.ton.hashmap/HashmapAugE : org.ton.hashmap/AugmentedDictionary<#A, #B>, org.ton.tlb/TlbObject { // org.ton.hashmap/HashmapAugE|null[0]
    abstract val n // org.ton.hashmap/HashmapAugE.n|{}n[0]
        abstract fun <get-n>(): kotlin/Int // org.ton.hashmap/HashmapAugE.n.<get-n>|<get-n>(){}[0]

    abstract fun get(org.ton.bitstring/BitString): org.ton.hashmap/HashmapAugNode.AhmnLeaf<#A, #B>? // org.ton.hashmap/HashmapAugE.get|get(org.ton.bitstring.BitString){}[0]
    abstract fun iterator(): kotlin.collections/Iterator<kotlin/Pair<org.ton.bitstring/BitString, org.ton.hashmap/HashmapAugNode<#A, #B>>> // org.ton.hashmap/HashmapAugE.iterator|iterator(){}[0]

    abstract interface <#A1: kotlin/Any?, #B1: kotlin/Any?> AhmeEmpty : org.ton.hashmap/HashmapAugE<#A1, #B1> { // org.ton.hashmap/HashmapAugE.AhmeEmpty|null[0]
        abstract val extra // org.ton.hashmap/HashmapAugE.AhmeEmpty.extra|{}extra[0]
            abstract fun <get-extra>(): #B1 // org.ton.hashmap/HashmapAugE.AhmeEmpty.extra.<get-extra>|<get-extra>(){}[0]
        abstract val n // org.ton.hashmap/HashmapAugE.AhmeEmpty.n|{}n[0]
            abstract fun <get-n>(): kotlin/Int // org.ton.hashmap/HashmapAugE.AhmeEmpty.n.<get-n>|<get-n>(){}[0]

        open fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HashmapAugE.AhmeEmpty.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]

        final object Companion { // org.ton.hashmap/HashmapAugE.AhmeEmpty.Companion|null[0]
            final fun <#A3: kotlin/Any?, #B3: kotlin/Any?> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#B3>): org.ton.tlb/TlbCodec<org.ton.hashmap/HashmapAugE.AhmeEmpty<#A3, #B3>> // org.ton.hashmap/HashmapAugE.AhmeEmpty.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        }
    }

    abstract interface <#A1: kotlin/Any?, #B1: kotlin/Any?> AhmeRoot : org.ton.hashmap/HashmapAugE<#A1, #B1> { // org.ton.hashmap/HashmapAugE.AhmeRoot|null[0]
        abstract val extra // org.ton.hashmap/HashmapAugE.AhmeRoot.extra|{}extra[0]
            abstract fun <get-extra>(): #B1 // org.ton.hashmap/HashmapAugE.AhmeRoot.extra.<get-extra>|<get-extra>(){}[0]
        abstract val n // org.ton.hashmap/HashmapAugE.AhmeRoot.n|{}n[0]
            abstract fun <get-n>(): kotlin/Int // org.ton.hashmap/HashmapAugE.AhmeRoot.n.<get-n>|<get-n>(){}[0]
        abstract val root // org.ton.hashmap/HashmapAugE.AhmeRoot.root|{}root[0]
            abstract fun <get-root>(): org.ton.tlb/CellRef<org.ton.hashmap/HashmapAug<#A1, #B1>> // org.ton.hashmap/HashmapAugE.AhmeRoot.root.<get-root>|<get-root>(){}[0]

        open fun loadRoot(): org.ton.hashmap/HashmapAug<#A1, #B1> // org.ton.hashmap/HashmapAugE.AhmeRoot.loadRoot|loadRoot(){}[0]
        open fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HashmapAugE.AhmeRoot.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]

        final object Companion { // org.ton.hashmap/HashmapAugE.AhmeRoot.Companion|null[0]
            final fun <#A3: kotlin/Any?, #B3: kotlin/Any?> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#A3>, org.ton.tlb/TlbCodec<#B3>): org.ton.tlb/TlbCodec<org.ton.hashmap/HashmapAugE.AhmeRoot<#A3, #B3>> // org.ton.hashmap/HashmapAugE.AhmeRoot.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:0>;org.ton.tlb.TlbCodec<0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        }
    }

    final object Companion { // org.ton.hashmap/HashmapAugE.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> empty(kotlin/Int, #B2): org.ton.hashmap/HashmapAugE.AhmeEmpty<#A2, #B2> // org.ton.hashmap/HashmapAugE.Companion.empty|empty(kotlin.Int;0:1){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> root(kotlin/Int, org.ton.tlb/CellRef<org.ton.hashmap/HashmapAug<#A2, #B2>>, #B2): org.ton.hashmap/HashmapAugE.AhmeRoot<#A2, #B2> // org.ton.hashmap/HashmapAugE.Companion.root|root(kotlin.Int;org.ton.tlb.CellRef<org.ton.hashmap.HashmapAug<0:0,0:1>>;0:1){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#A2>, org.ton.tlb/TlbCodec<#B2>): org.ton.tlb/TlbCodec<org.ton.hashmap/HashmapAugE<#A2, #B2>> // org.ton.hashmap/HashmapAugE.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:0>;org.ton.tlb.TlbCodec<0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    }
}

abstract interface <#A: kotlin/Any?, #B: kotlin/Any?> org.ton.hashmap/HashmapAugNode : org.ton.hashmap/AugmentedDictionary.Node<#A, #B>, org.ton.tlb/TlbObject { // org.ton.hashmap/HashmapAugNode|null[0]
    abstract val n // org.ton.hashmap/HashmapAugNode.n|{}n[0]
        abstract fun <get-n>(): kotlin/Int // org.ton.hashmap/HashmapAugNode.n.<get-n>|<get-n>(){}[0]

    abstract interface <#A1: kotlin/Any?, #B1: kotlin/Any?> AhmnFork : org.ton.hashmap/HashmapAugNode<#A1, #B1> { // org.ton.hashmap/HashmapAugNode.AhmnFork|null[0]
        abstract val extra // org.ton.hashmap/HashmapAugNode.AhmnFork.extra|{}extra[0]
            abstract fun <get-extra>(): #B1 // org.ton.hashmap/HashmapAugNode.AhmnFork.extra.<get-extra>|<get-extra>(){}[0]
        abstract val left // org.ton.hashmap/HashmapAugNode.AhmnFork.left|{}left[0]
            abstract fun <get-left>(): org.ton.tlb/CellRef<org.ton.hashmap/HashmapAug<#A1, #B1>> // org.ton.hashmap/HashmapAugNode.AhmnFork.left.<get-left>|<get-left>(){}[0]
        abstract val n // org.ton.hashmap/HashmapAugNode.AhmnFork.n|{}n[0]
            abstract fun <get-n>(): kotlin/Int // org.ton.hashmap/HashmapAugNode.AhmnFork.n.<get-n>|<get-n>(){}[0]
        abstract val right // org.ton.hashmap/HashmapAugNode.AhmnFork.right|{}right[0]
            abstract fun <get-right>(): org.ton.tlb/CellRef<org.ton.hashmap/HashmapAug<#A1, #B1>> // org.ton.hashmap/HashmapAugNode.AhmnFork.right.<get-right>|<get-right>(){}[0]
        open val value // org.ton.hashmap/HashmapAugNode.AhmnFork.value|{}value[0]
            open fun <get-value>(): #A1? // org.ton.hashmap/HashmapAugNode.AhmnFork.value.<get-value>|<get-value>(){}[0]

        open fun loadLeft(): org.ton.hashmap/HashmapAug<#A1, #B1> // org.ton.hashmap/HashmapAugNode.AhmnFork.loadLeft|loadLeft(){}[0]
        open fun loadRight(): org.ton.hashmap/HashmapAug<#A1, #B1> // org.ton.hashmap/HashmapAugNode.AhmnFork.loadRight|loadRight(){}[0]
        open fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HashmapAugNode.AhmnFork.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]

        final object Companion { // org.ton.hashmap/HashmapAugNode.AhmnFork.Companion|null[0]
            final fun <#A3: kotlin/Any?, #B3: kotlin/Any?> tlbCodec(org.ton.tlb/TlbCodec<#A3>, org.ton.tlb/TlbCodec<#B3>, kotlin/Int): org.ton.tlb/TlbCodec<org.ton.hashmap/HashmapAugNode.AhmnFork<#A3, #B3>> // org.ton.hashmap/HashmapAugNode.AhmnFork.Companion.tlbCodec|tlbCodec(org.ton.tlb.TlbCodec<0:0>;org.ton.tlb.TlbCodec<0:1>;kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        }
    }

    abstract interface <#A1: kotlin/Any?, #B1: kotlin/Any?> AhmnLeaf : org.ton.hashmap/AugmentedDictionary.Leaf<#A1, #B1>, org.ton.hashmap/HashmapAugNode<#A1, #B1> { // org.ton.hashmap/HashmapAugNode.AhmnLeaf|null[0]
        abstract val extra // org.ton.hashmap/HashmapAugNode.AhmnLeaf.extra|{}extra[0]
            abstract fun <get-extra>(): #B1 // org.ton.hashmap/HashmapAugNode.AhmnLeaf.extra.<get-extra>|<get-extra>(){}[0]
        abstract val value // org.ton.hashmap/HashmapAugNode.AhmnLeaf.value|{}value[0]
            abstract fun <get-value>(): #A1 // org.ton.hashmap/HashmapAugNode.AhmnLeaf.value.<get-value>|<get-value>(){}[0]
        open val n // org.ton.hashmap/HashmapAugNode.AhmnLeaf.n|{}n[0]
            open fun <get-n>(): kotlin/Int // org.ton.hashmap/HashmapAugNode.AhmnLeaf.n.<get-n>|<get-n>(){}[0]

        open fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HashmapAugNode.AhmnLeaf.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]

        final object Companion { // org.ton.hashmap/HashmapAugNode.AhmnLeaf.Companion|null[0]
            final fun <#A3: kotlin/Any?, #B3: kotlin/Any?> tlbCodec(org.ton.tlb/TlbCodec<#A3>, org.ton.tlb/TlbCodec<#B3>): org.ton.tlb/TlbCodec<org.ton.hashmap/HashmapAugNode.AhmnLeaf<#A3, #B3>> // org.ton.hashmap/HashmapAugNode.AhmnLeaf.Companion.tlbCodec|tlbCodec(org.ton.tlb.TlbCodec<0:0>;org.ton.tlb.TlbCodec<0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        }
    }

    final object Companion { // org.ton.hashmap/HashmapAugNode.Companion|null[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> fork(kotlin/Int, org.ton.tlb/CellRef<org.ton.hashmap/HashmapAug<#A2, #B2>>, org.ton.tlb/CellRef<org.ton.hashmap/HashmapAug<#A2, #B2>>, #B2): org.ton.hashmap/HashmapAugNode.AhmnFork<#A2, #B2> // org.ton.hashmap/HashmapAugNode.Companion.fork|fork(kotlin.Int;org.ton.tlb.CellRef<org.ton.hashmap.HashmapAug<0:0,0:1>>;org.ton.tlb.CellRef<org.ton.hashmap.HashmapAug<0:0,0:1>>;0:1){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> leaf(#B2, #A2): org.ton.hashmap/HashmapAugNode.AhmnLeaf<#A2, #B2> // org.ton.hashmap/HashmapAugNode.Companion.leaf|leaf(0:1;0:0){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?, #B2: kotlin/Any?> tlbCodec(org.ton.tlb/TlbCodec<#A2>, org.ton.tlb/TlbCodec<#B2>, kotlin/Int): org.ton.tlb/TlbCodec<org.ton.hashmap/HashmapAugNode<#A2, #B2>> // org.ton.hashmap/HashmapAugNode.Companion.tlbCodec|tlbCodec(org.ton.tlb.TlbCodec<0:0>;org.ton.tlb.TlbCodec<0:1>;kotlin.Int){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    }
}

sealed interface <#A: kotlin/Any?> org.ton.hashmap/HashMapE : kotlin.collections/Iterable<kotlin/Pair<org.ton.bitstring/BitString, #A>>, org.ton.tlb/TlbObject { // org.ton.hashmap/HashMapE|null[0]
    abstract fun iterator(): kotlin.collections/Iterator<kotlin/Pair<org.ton.bitstring/BitString, #A>> // org.ton.hashmap/HashMapE.iterator|iterator(){}[0]

    final object Companion : kotlinx.serialization.internal/SerializerFactory { // org.ton.hashmap/HashMapE.Companion|null[0]
        final fun <#A2: kotlin/Any> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#A2>): org.ton.tlb/TlbCodec<org.ton.hashmap/HashMapE<#A2>> // org.ton.hashmap/HashMapE.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:0>){0§<kotlin.Any>}[0]
        final fun <#A2: kotlin/Any?> empty(): org.ton.hashmap/HashMapE<#A2> // org.ton.hashmap/HashMapE.Companion.empty|empty(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> of(): org.ton.hashmap/HashMapE<#A2> // org.ton.hashmap/HashMapE.Companion.of|of(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> root(org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A2>>): org.ton.hashmap/HashMapE<#A2> // org.ton.hashmap/HashMapE.Companion.root|root(org.ton.tlb.CellRef<org.ton.hashmap.HmEdge<0:0>>){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> serializer(kotlinx.serialization/KSerializer<#A2>): kotlinx.serialization/KSerializer<org.ton.hashmap/HashMapE<#A2>> // org.ton.hashmap/HashMapE.Companion.serializer|serializer(kotlinx.serialization.KSerializer<0:0>){0§<kotlin.Any?>}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/HashMapE.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
    }
}

sealed interface <#A: kotlin/Any?> org.ton.hashmap/HashMapNode : org.ton.tlb/TlbObject { // org.ton.hashmap/HashMapNode|null[0]
    final object Companion : kotlinx.serialization.internal/SerializerFactory { // org.ton.hashmap/HashMapNode.Companion|null[0]
        final fun <#A2: kotlin/Any?> leaf(#A2): org.ton.hashmap/HmnLeaf<#A2> // org.ton.hashmap/HashMapNode.Companion.leaf|leaf(0:0){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> serializer(kotlinx.serialization/KSerializer<#A2>): kotlinx.serialization/KSerializer<org.ton.hashmap/HashMapNode<#A2>> // org.ton.hashmap/HashMapNode.Companion.serializer|serializer(kotlinx.serialization.KSerializer<0:0>){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#A2>): org.ton.tlb/TlbCodec<org.ton.hashmap/HashMapNode<#A2>> // org.ton.hashmap/HashMapNode.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:0>){0§<kotlin.Any?>}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/HashMapNode.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
    }
}

sealed interface org.ton.hashmap/HmLabel : org.ton.tlb/TlbObject { // org.ton.hashmap/HmLabel|null[0]
    abstract fun toBitString(): org.ton.bitstring/BitString // org.ton.hashmap/HmLabel.toBitString|toBitString(){}[0]

    final object Companion : kotlinx.serialization.internal/SerializerFactory { // org.ton.hashmap/HmLabel.Companion|null[0]
        final fun empty(): org.ton.hashmap/HmLabel // org.ton.hashmap/HmLabel.Companion.empty|empty(){}[0]
        final fun of(org.ton.bitstring/BitString, kotlin/Int = ...): org.ton.hashmap/HmLabel // org.ton.hashmap/HmLabel.Companion.of|of(org.ton.bitstring.BitString;kotlin.Int){}[0]
        final fun serializer(): kotlinx.serialization/KSerializer<org.ton.hashmap/HmLabel> // org.ton.hashmap/HmLabel.Companion.serializer|serializer(){}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/HmLabel.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
        final fun tlbCodec(kotlin/Int): org.ton.tlb/TlbNegatedCodec<org.ton.hashmap/HmLabel> // org.ton.hashmap/HmLabel.Companion.tlbCodec|tlbCodec(kotlin.Int){}[0]
    }
}

final class <#A: kotlin/Any?> org.ton.hashmap/HmEdge : kotlin.collections/Iterable<kotlin/Pair<org.ton.bitstring/BitString, #A>>, org.ton.tlb/TlbObject { // org.ton.hashmap/HmEdge|null[0]
    constructor <init>(org.ton.hashmap/HmLabel, org.ton.hashmap/HashMapNode<#A>) // org.ton.hashmap/HmEdge.<init>|<init>(org.ton.hashmap.HmLabel;org.ton.hashmap.HashMapNode<1:0>){}[0]

    final val label // org.ton.hashmap/HmEdge.label|{}label[0]
        final fun <get-label>(): org.ton.hashmap/HmLabel // org.ton.hashmap/HmEdge.label.<get-label>|<get-label>(){}[0]
    final val node // org.ton.hashmap/HmEdge.node|{}node[0]
        final fun <get-node>(): org.ton.hashmap/HashMapNode<#A> // org.ton.hashmap/HmEdge.node.<get-node>|<get-node>(){}[0]

    final fun component1(): org.ton.hashmap/HmLabel // org.ton.hashmap/HmEdge.component1|component1(){}[0]
    final fun component2(): org.ton.hashmap/HashMapNode<#A> // org.ton.hashmap/HmEdge.component2|component2(){}[0]
    final fun copy(org.ton.hashmap/HmLabel = ..., org.ton.hashmap/HashMapNode<#A> = ...): org.ton.hashmap/HmEdge<#A> // org.ton.hashmap/HmEdge.copy|copy(org.ton.hashmap.HmLabel;org.ton.hashmap.HashMapNode<1:0>){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.hashmap/HmEdge.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.hashmap/HmEdge.hashCode|hashCode(){}[0]
    final fun iterator(): kotlin.collections/Iterator<kotlin/Pair<org.ton.bitstring/BitString, #A>> // org.ton.hashmap/HmEdge.iterator|iterator(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HmEdge.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/HmEdge.toString|toString(){}[0]

    final class <#A1: kotlin/Any?> $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/HmEdge<#A1>> { // org.ton.hashmap/HmEdge.$serializer|null[0]
        constructor <init>(kotlinx.serialization/KSerializer<#A1>) // org.ton.hashmap/HmEdge.$serializer.<init>|<init>(kotlinx.serialization.KSerializer<1:0>){}[0]

        final val descriptor // org.ton.hashmap/HmEdge.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmEdge.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]
        final val typeSerial0 // org.ton.hashmap/HmEdge.$serializer.typeSerial0|{}typeSerial0[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmEdge.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/HmEdge<#A1> // org.ton.hashmap/HmEdge.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/HmEdge<#A1>) // org.ton.hashmap/HmEdge.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.HmEdge<1:0>){}[0]
        final fun typeParametersSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmEdge.$serializer.typeParametersSerializers|typeParametersSerializers(){}[0]
    }

    final object Companion : kotlinx.serialization.internal/SerializerFactory { // org.ton.hashmap/HmEdge.Companion|null[0]
        final const val ADD // org.ton.hashmap/HmEdge.Companion.ADD|{}ADD[0]
            final fun <get-ADD>(): kotlin/Int // org.ton.hashmap/HmEdge.Companion.ADD.<get-ADD>|<get-ADD>(){}[0]
        final const val REPLACE // org.ton.hashmap/HmEdge.Companion.REPLACE|{}REPLACE[0]
            final fun <get-REPLACE>(): kotlin/Int // org.ton.hashmap/HmEdge.Companion.REPLACE.<get-REPLACE>|<get-REPLACE>(){}[0]

        final val $cachedDescriptor // org.ton.hashmap/HmEdge.Companion.$cachedDescriptor|{}$cachedDescriptor[0]
            final fun <get-$cachedDescriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmEdge.Companion.$cachedDescriptor.<get-$cachedDescriptor>|<get-$cachedDescriptor>(){}[0]
        final val $childSerializers // org.ton.hashmap/HmEdge.Companion.$childSerializers|{}$childSerializers[0]

        final fun <#A2: kotlin/Any?> serializer(kotlinx.serialization/KSerializer<#A2>): kotlinx.serialization/KSerializer<org.ton.hashmap/HmEdge<#A2>> // org.ton.hashmap/HmEdge.Companion.serializer|serializer(kotlinx.serialization.KSerializer<0:0>){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#A2>): org.ton.tlb/TlbCodec<org.ton.hashmap/HmEdge<#A2>> // org.ton.hashmap/HmEdge.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:0>){0§<kotlin.Any?>}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/HmEdge.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
    }
}

final class <#A: kotlin/Any?> org.ton.hashmap/HmeEmpty : org.ton.hashmap/HashMapE<#A> { // org.ton.hashmap/HmeEmpty|null[0]
    constructor <init>() // org.ton.hashmap/HmeEmpty.<init>|<init>(){}[0]

    final fun iterator(): kotlin.collections/Iterator<kotlin/Pair<org.ton.bitstring/BitString, #A>> // org.ton.hashmap/HmeEmpty.iterator|iterator(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HmeEmpty.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/HmeEmpty.toString|toString(){}[0]

    final class <#A1: kotlin/Any?> $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/HmeEmpty<#A1>> { // org.ton.hashmap/HmeEmpty.$serializer|null[0]
        constructor <init>(kotlinx.serialization/KSerializer<#A1>) // org.ton.hashmap/HmeEmpty.$serializer.<init>|<init>(kotlinx.serialization.KSerializer<1:0>){}[0]

        final val descriptor // org.ton.hashmap/HmeEmpty.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmeEmpty.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]
        final val typeSerial0 // org.ton.hashmap/HmeEmpty.$serializer.typeSerial0|{}typeSerial0[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmeEmpty.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/HmeEmpty<#A1> // org.ton.hashmap/HmeEmpty.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/HmeEmpty<#A1>) // org.ton.hashmap/HmeEmpty.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.HmeEmpty<1:0>){}[0]
        final fun typeParametersSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmeEmpty.$serializer.typeParametersSerializers|typeParametersSerializers(){}[0]
    }

    final object Companion : kotlinx.serialization.internal/SerializerFactory { // org.ton.hashmap/HmeEmpty.Companion|null[0]
        final val $cachedDescriptor // org.ton.hashmap/HmeEmpty.Companion.$cachedDescriptor|{}$cachedDescriptor[0]
            final fun <get-$cachedDescriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmeEmpty.Companion.$cachedDescriptor.<get-$cachedDescriptor>|<get-$cachedDescriptor>(){}[0]

        final fun <#A2: kotlin/Any?> serializer(kotlinx.serialization/KSerializer<#A2>): kotlinx.serialization/KSerializer<org.ton.hashmap/HmeEmpty<#A2>> // org.ton.hashmap/HmeEmpty.Companion.serializer|serializer(kotlinx.serialization.KSerializer<0:0>){0§<kotlin.Any?>}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/HmeEmpty.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
    }
}

final class <#A: kotlin/Any?> org.ton.hashmap/HmeRoot : org.ton.hashmap/HashMapE<#A> { // org.ton.hashmap/HmeRoot|null[0]
    constructor <init>(org.ton.cell/Cell, org.ton.tlb/TlbCodec<org.ton.hashmap/HmEdge<#A>>) // org.ton.hashmap/HmeRoot.<init>|<init>(org.ton.cell.Cell;org.ton.tlb.TlbCodec<org.ton.hashmap.HmEdge<1:0>>){}[0]
    constructor <init>(org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>>) // org.ton.hashmap/HmeRoot.<init>|<init>(org.ton.tlb.CellRef<org.ton.hashmap.HmEdge<1:0>>){}[0]

    final val root // org.ton.hashmap/HmeRoot.root|{}root[0]
        final fun <get-root>(): org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> // org.ton.hashmap/HmeRoot.root.<get-root>|<get-root>(){}[0]

    final fun component1(): org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> // org.ton.hashmap/HmeRoot.component1|component1(){}[0]
    final fun copy(org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> = ...): org.ton.hashmap/HmeRoot<#A> // org.ton.hashmap/HmeRoot.copy|copy(org.ton.tlb.CellRef<org.ton.hashmap.HmEdge<1:0>>){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.hashmap/HmeRoot.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.hashmap/HmeRoot.hashCode|hashCode(){}[0]
    final fun iterator(): kotlin.collections/Iterator<kotlin/Pair<org.ton.bitstring/BitString, #A>> // org.ton.hashmap/HmeRoot.iterator|iterator(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HmeRoot.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/HmeRoot.toString|toString(){}[0]

    final class <#A1: kotlin/Any?> $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/HmeRoot<#A1>> { // org.ton.hashmap/HmeRoot.$serializer|null[0]
        constructor <init>(kotlinx.serialization/KSerializer<#A1>) // org.ton.hashmap/HmeRoot.$serializer.<init>|<init>(kotlinx.serialization.KSerializer<1:0>){}[0]

        final val descriptor // org.ton.hashmap/HmeRoot.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmeRoot.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]
        final val typeSerial0 // org.ton.hashmap/HmeRoot.$serializer.typeSerial0|{}typeSerial0[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmeRoot.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/HmeRoot<#A1> // org.ton.hashmap/HmeRoot.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/HmeRoot<#A1>) // org.ton.hashmap/HmeRoot.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.HmeRoot<1:0>){}[0]
        final fun typeParametersSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmeRoot.$serializer.typeParametersSerializers|typeParametersSerializers(){}[0]
    }

    final object Companion : kotlinx.serialization.internal/SerializerFactory { // org.ton.hashmap/HmeRoot.Companion|null[0]
        final val $cachedDescriptor // org.ton.hashmap/HmeRoot.Companion.$cachedDescriptor|{}$cachedDescriptor[0]
            final fun <get-$cachedDescriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmeRoot.Companion.$cachedDescriptor.<get-$cachedDescriptor>|<get-$cachedDescriptor>(){}[0]

        final fun <#A2: kotlin/Any?> serializer(kotlinx.serialization/KSerializer<#A2>): kotlinx.serialization/KSerializer<org.ton.hashmap/HmeRoot<#A2>> // org.ton.hashmap/HmeRoot.Companion.serializer|serializer(kotlinx.serialization.KSerializer<0:0>){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tlbConstructor(kotlin/Int, org.ton.tlb/TlbCodec<#A2>): org.ton.tlb/TlbConstructor<org.ton.hashmap/HmeRoot<#A2>> // org.ton.hashmap/HmeRoot.Companion.tlbConstructor|tlbConstructor(kotlin.Int;org.ton.tlb.TlbCodec<0:0>){0§<kotlin.Any?>}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/HmeRoot.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
    }
}

final class <#A: kotlin/Any?> org.ton.hashmap/HmnFork : org.ton.hashmap/HashMapNode<#A> { // org.ton.hashmap/HmnFork|null[0]
    constructor <init>(org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>>, org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>>) // org.ton.hashmap/HmnFork.<init>|<init>(org.ton.tlb.CellRef<org.ton.hashmap.HmEdge<1:0>>;org.ton.tlb.CellRef<org.ton.hashmap.HmEdge<1:0>>){}[0]

    final val left // org.ton.hashmap/HmnFork.left|{}left[0]
        final fun <get-left>(): org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> // org.ton.hashmap/HmnFork.left.<get-left>|<get-left>(){}[0]
    final val right // org.ton.hashmap/HmnFork.right|{}right[0]
        final fun <get-right>(): org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> // org.ton.hashmap/HmnFork.right.<get-right>|<get-right>(){}[0]

    final fun component1(): org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> // org.ton.hashmap/HmnFork.component1|component1(){}[0]
    final fun component2(): org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> // org.ton.hashmap/HmnFork.component2|component2(){}[0]
    final fun copy(org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> = ..., org.ton.tlb/CellRef<org.ton.hashmap/HmEdge<#A>> = ...): org.ton.hashmap/HmnFork<#A> // org.ton.hashmap/HmnFork.copy|copy(org.ton.tlb.CellRef<org.ton.hashmap.HmEdge<1:0>>;org.ton.tlb.CellRef<org.ton.hashmap.HmEdge<1:0>>){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.hashmap/HmnFork.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.hashmap/HmnFork.hashCode|hashCode(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HmnFork.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/HmnFork.toString|toString(){}[0]

    final class <#A1: kotlin/Any?> $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/HmnFork<#A1>> { // org.ton.hashmap/HmnFork.$serializer|null[0]
        constructor <init>(kotlinx.serialization/KSerializer<#A1>) // org.ton.hashmap/HmnFork.$serializer.<init>|<init>(kotlinx.serialization.KSerializer<1:0>){}[0]

        final val descriptor // org.ton.hashmap/HmnFork.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmnFork.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]
        final val typeSerial0 // org.ton.hashmap/HmnFork.$serializer.typeSerial0|{}typeSerial0[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmnFork.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/HmnFork<#A1> // org.ton.hashmap/HmnFork.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/HmnFork<#A1>) // org.ton.hashmap/HmnFork.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.HmnFork<1:0>){}[0]
        final fun typeParametersSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmnFork.$serializer.typeParametersSerializers|typeParametersSerializers(){}[0]
    }

    final object Companion : kotlinx.serialization.internal/SerializerFactory { // org.ton.hashmap/HmnFork.Companion|null[0]
        final val $cachedDescriptor // org.ton.hashmap/HmnFork.Companion.$cachedDescriptor|{}$cachedDescriptor[0]
            final fun <get-$cachedDescriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmnFork.Companion.$cachedDescriptor.<get-$cachedDescriptor>|<get-$cachedDescriptor>(){}[0]

        final fun <#A2: kotlin/Any?> serializer(kotlinx.serialization/KSerializer<#A2>): kotlinx.serialization/KSerializer<org.ton.hashmap/HmnFork<#A2>> // org.ton.hashmap/HmnFork.Companion.serializer|serializer(kotlinx.serialization.KSerializer<0:0>){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tlbCodec(kotlin/Int, org.ton.tlb/TlbCodec<#A2>): org.ton.tlb/TlbCodec<org.ton.hashmap/HmnFork<#A2>> // org.ton.hashmap/HmnFork.Companion.tlbCodec|tlbCodec(kotlin.Int;org.ton.tlb.TlbCodec<0:0>){0§<kotlin.Any?>}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/HmnFork.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
    }
}

final class <#A: kotlin/Any?> org.ton.hashmap/HmnLeaf : org.ton.hashmap/HashMapNode<#A> { // org.ton.hashmap/HmnLeaf|null[0]
    constructor <init>(#A) // org.ton.hashmap/HmnLeaf.<init>|<init>(1:0){}[0]

    final val value // org.ton.hashmap/HmnLeaf.value|{}value[0]
        final fun <get-value>(): #A // org.ton.hashmap/HmnLeaf.value.<get-value>|<get-value>(){}[0]

    final fun component1(): #A // org.ton.hashmap/HmnLeaf.component1|component1(){}[0]
    final fun copy(#A = ...): org.ton.hashmap/HmnLeaf<#A> // org.ton.hashmap/HmnLeaf.copy|copy(1:0){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.hashmap/HmnLeaf.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.hashmap/HmnLeaf.hashCode|hashCode(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HmnLeaf.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/HmnLeaf.toString|toString(){}[0]

    final class <#A1: kotlin/Any?> $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/HmnLeaf<#A1>> { // org.ton.hashmap/HmnLeaf.$serializer|null[0]
        constructor <init>(kotlinx.serialization/KSerializer<#A1>) // org.ton.hashmap/HmnLeaf.$serializer.<init>|<init>(kotlinx.serialization.KSerializer<1:0>){}[0]

        final val descriptor // org.ton.hashmap/HmnLeaf.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmnLeaf.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]
        final val typeSerial0 // org.ton.hashmap/HmnLeaf.$serializer.typeSerial0|{}typeSerial0[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmnLeaf.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/HmnLeaf<#A1> // org.ton.hashmap/HmnLeaf.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/HmnLeaf<#A1>) // org.ton.hashmap/HmnLeaf.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.HmnLeaf<1:0>){}[0]
        final fun typeParametersSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmnLeaf.$serializer.typeParametersSerializers|typeParametersSerializers(){}[0]
    }

    final object Companion : kotlinx.serialization.internal/SerializerFactory { // org.ton.hashmap/HmnLeaf.Companion|null[0]
        final val $cachedDescriptor // org.ton.hashmap/HmnLeaf.Companion.$cachedDescriptor|{}$cachedDescriptor[0]
            final fun <get-$cachedDescriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmnLeaf.Companion.$cachedDescriptor.<get-$cachedDescriptor>|<get-$cachedDescriptor>(){}[0]

        final fun <#A2: kotlin/Any?> serializer(kotlinx.serialization/KSerializer<#A2>): kotlinx.serialization/KSerializer<org.ton.hashmap/HmnLeaf<#A2>> // org.ton.hashmap/HmnLeaf.Companion.serializer|serializer(kotlinx.serialization.KSerializer<0:0>){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> tlbCodec(org.ton.tlb/TlbCodec<#A2>): org.ton.tlb/TlbCodec<org.ton.hashmap/HmnLeaf<#A2>> // org.ton.hashmap/HmnLeaf.Companion.tlbCodec|tlbCodec(org.ton.tlb.TlbCodec<0:0>){0§<kotlin.Any?>}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/HmnLeaf.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
    }
}

final class org.ton.hashmap/HmlLong : org.ton.hashmap/HmLabel { // org.ton.hashmap/HmlLong|null[0]
    constructor <init>(kotlin/Int, org.ton.bitstring/BitString) // org.ton.hashmap/HmlLong.<init>|<init>(kotlin.Int;org.ton.bitstring.BitString){}[0]
    constructor <init>(org.ton.bitstring/BitString) // org.ton.hashmap/HmlLong.<init>|<init>(org.ton.bitstring.BitString){}[0]

    final val n // org.ton.hashmap/HmlLong.n|{}n[0]
        final fun <get-n>(): kotlin/Int // org.ton.hashmap/HmlLong.n.<get-n>|<get-n>(){}[0]
    final val s // org.ton.hashmap/HmlLong.s|{}s[0]
        final fun <get-s>(): org.ton.bitstring/BitString // org.ton.hashmap/HmlLong.s.<get-s>|<get-s>(){}[0]

    final fun component1(): kotlin/Int // org.ton.hashmap/HmlLong.component1|component1(){}[0]
    final fun component2(): org.ton.bitstring/BitString // org.ton.hashmap/HmlLong.component2|component2(){}[0]
    final fun copy(kotlin/Int = ..., org.ton.bitstring/BitString = ...): org.ton.hashmap/HmlLong // org.ton.hashmap/HmlLong.copy|copy(kotlin.Int;org.ton.bitstring.BitString){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.hashmap/HmlLong.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.hashmap/HmlLong.hashCode|hashCode(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HmlLong.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toBitString(): org.ton.bitstring/BitString // org.ton.hashmap/HmlLong.toBitString|toBitString(){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/HmlLong.toString|toString(){}[0]

    final object $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/HmlLong> { // org.ton.hashmap/HmlLong.$serializer|null[0]
        final val descriptor // org.ton.hashmap/HmlLong.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmlLong.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmlLong.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/HmlLong // org.ton.hashmap/HmlLong.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/HmlLong) // org.ton.hashmap/HmlLong.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.HmlLong){}[0]
    }

    final object Companion { // org.ton.hashmap/HmlLong.Companion|null[0]
        final fun serializer(): kotlinx.serialization/KSerializer<org.ton.hashmap/HmlLong> // org.ton.hashmap/HmlLong.Companion.serializer|serializer(){}[0]
        final fun tlbCodec(kotlin/Int): org.ton.tlb/TlbNegatedConstructor<org.ton.hashmap/HmlLong> // org.ton.hashmap/HmlLong.Companion.tlbCodec|tlbCodec(kotlin.Int){}[0]
    }
}

final class org.ton.hashmap/HmlSame : org.ton.hashmap/HmLabel { // org.ton.hashmap/HmlSame|null[0]
    constructor <init>(kotlin/Boolean, kotlin/Int) // org.ton.hashmap/HmlSame.<init>|<init>(kotlin.Boolean;kotlin.Int){}[0]
    constructor <init>(kotlin/Int, kotlin/Int) // org.ton.hashmap/HmlSame.<init>|<init>(kotlin.Int;kotlin.Int){}[0]

    final val n // org.ton.hashmap/HmlSame.n|{}n[0]
        final fun <get-n>(): kotlin/Int // org.ton.hashmap/HmlSame.n.<get-n>|<get-n>(){}[0]
    final val v // org.ton.hashmap/HmlSame.v|{}v[0]
        final fun <get-v>(): kotlin/Boolean // org.ton.hashmap/HmlSame.v.<get-v>|<get-v>(){}[0]

    final fun component1(): kotlin/Boolean // org.ton.hashmap/HmlSame.component1|component1(){}[0]
    final fun component2(): kotlin/Int // org.ton.hashmap/HmlSame.component2|component2(){}[0]
    final fun copy(kotlin/Boolean = ..., kotlin/Int = ...): org.ton.hashmap/HmlSame // org.ton.hashmap/HmlSame.copy|copy(kotlin.Boolean;kotlin.Int){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.hashmap/HmlSame.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.hashmap/HmlSame.hashCode|hashCode(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HmlSame.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toBitString(): org.ton.bitstring/BitString // org.ton.hashmap/HmlSame.toBitString|toBitString(){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/HmlSame.toString|toString(){}[0]

    final object $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/HmlSame> { // org.ton.hashmap/HmlSame.$serializer|null[0]
        final val descriptor // org.ton.hashmap/HmlSame.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmlSame.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmlSame.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/HmlSame // org.ton.hashmap/HmlSame.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/HmlSame) // org.ton.hashmap/HmlSame.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.HmlSame){}[0]
    }

    final object Companion { // org.ton.hashmap/HmlSame.Companion|null[0]
        final fun of(org.ton.bitstring/BitString, kotlin/Int = ...): org.ton.hashmap/HmlSame? // org.ton.hashmap/HmlSame.Companion.of|of(org.ton.bitstring.BitString;kotlin.Int){}[0]
        final fun serializer(): kotlinx.serialization/KSerializer<org.ton.hashmap/HmlSame> // org.ton.hashmap/HmlSame.Companion.serializer|serializer(){}[0]
        final fun tlbCodec(kotlin/Int): org.ton.tlb/TlbNegatedConstructor<org.ton.hashmap/HmlSame> // org.ton.hashmap/HmlSame.Companion.tlbCodec|tlbCodec(kotlin.Int){}[0]
    }
}

final class org.ton.hashmap/HmlShort : org.ton.hashmap/HmLabel { // org.ton.hashmap/HmlShort|null[0]
    constructor <init>(org.ton.bitstring/BitString) // org.ton.hashmap/HmlShort.<init>|<init>(org.ton.bitstring.BitString){}[0]
    constructor <init>(org.ton.hashmap/Unary, org.ton.bitstring/BitString) // org.ton.hashmap/HmlShort.<init>|<init>(org.ton.hashmap.Unary;org.ton.bitstring.BitString){}[0]

    final val len // org.ton.hashmap/HmlShort.len|{}len[0]
        final fun <get-len>(): org.ton.hashmap/Unary // org.ton.hashmap/HmlShort.len.<get-len>|<get-len>(){}[0]
    final val s // org.ton.hashmap/HmlShort.s|{}s[0]
        final fun <get-s>(): org.ton.bitstring/BitString // org.ton.hashmap/HmlShort.s.<get-s>|<get-s>(){}[0]

    final fun component1(): org.ton.hashmap/Unary // org.ton.hashmap/HmlShort.component1|component1(){}[0]
    final fun component2(): org.ton.bitstring/BitString // org.ton.hashmap/HmlShort.component2|component2(){}[0]
    final fun copy(org.ton.hashmap/Unary = ..., org.ton.bitstring/BitString = ...): org.ton.hashmap/HmlShort // org.ton.hashmap/HmlShort.copy|copy(org.ton.hashmap.Unary;org.ton.bitstring.BitString){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.hashmap/HmlShort.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.hashmap/HmlShort.hashCode|hashCode(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/HmlShort.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toBitString(): org.ton.bitstring/BitString // org.ton.hashmap/HmlShort.toBitString|toBitString(){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/HmlShort.toString|toString(){}[0]

    final object $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/HmlShort> { // org.ton.hashmap/HmlShort.$serializer|null[0]
        final val descriptor // org.ton.hashmap/HmlShort.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/HmlShort.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/HmlShort.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/HmlShort // org.ton.hashmap/HmlShort.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/HmlShort) // org.ton.hashmap/HmlShort.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.HmlShort){}[0]
    }

    final object Companion { // org.ton.hashmap/HmlShort.Companion|null[0]
        final val $childSerializers // org.ton.hashmap/HmlShort.Companion.$childSerializers|{}$childSerializers[0]

        final fun empty(): org.ton.hashmap/HmlShort // org.ton.hashmap/HmlShort.Companion.empty|empty(){}[0]
        final fun serializer(): kotlinx.serialization/KSerializer<org.ton.hashmap/HmlShort> // org.ton.hashmap/HmlShort.Companion.serializer|serializer(){}[0]
        final fun tlbCodec(): org.ton.tlb/TlbNegatedConstructor<org.ton.hashmap/HmlShort> // org.ton.hashmap/HmlShort.Companion.tlbCodec|tlbCodec(){}[0]
    }
}

final class org.ton.hashmap/UnarySuccess : org.ton.hashmap/Unary { // org.ton.hashmap/UnarySuccess|null[0]
    constructor <init>(org.ton.hashmap/Unary) // org.ton.hashmap/UnarySuccess.<init>|<init>(org.ton.hashmap.Unary){}[0]

    final val x // org.ton.hashmap/UnarySuccess.x|{}x[0]
        final fun <get-x>(): org.ton.hashmap/Unary // org.ton.hashmap/UnarySuccess.x.<get-x>|<get-x>(){}[0]

    final fun component1(): org.ton.hashmap/Unary // org.ton.hashmap/UnarySuccess.component1|component1(){}[0]
    final fun copy(org.ton.hashmap/Unary = ...): org.ton.hashmap/UnarySuccess // org.ton.hashmap/UnarySuccess.copy|copy(org.ton.hashmap.Unary){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.hashmap/UnarySuccess.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.hashmap/UnarySuccess.hashCode|hashCode(){}[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/UnarySuccess.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/UnarySuccess.toString|toString(){}[0]

    final object $serializer : kotlinx.serialization.internal/GeneratedSerializer<org.ton.hashmap/UnarySuccess> { // org.ton.hashmap/UnarySuccess.$serializer|null[0]
        final val descriptor // org.ton.hashmap/UnarySuccess.$serializer.descriptor|{}descriptor[0]
            final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // org.ton.hashmap/UnarySuccess.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]

        final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // org.ton.hashmap/UnarySuccess.$serializer.childSerializers|childSerializers(){}[0]
        final fun deserialize(kotlinx.serialization.encoding/Decoder): org.ton.hashmap/UnarySuccess // org.ton.hashmap/UnarySuccess.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
        final fun serialize(kotlinx.serialization.encoding/Encoder, org.ton.hashmap/UnarySuccess) // org.ton.hashmap/UnarySuccess.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;org.ton.hashmap.UnarySuccess){}[0]
    }

    final object Companion { // org.ton.hashmap/UnarySuccess.Companion|null[0]
        final val $childSerializers // org.ton.hashmap/UnarySuccess.Companion.$childSerializers|{}$childSerializers[0]

        final fun serializer(): kotlinx.serialization/KSerializer<org.ton.hashmap/UnarySuccess> // org.ton.hashmap/UnarySuccess.Companion.serializer|serializer(){}[0]
    }
}

sealed class org.ton.hashmap/Unary : org.ton.tlb/TlbObject { // org.ton.hashmap/Unary|null[0]
    final object Companion : kotlinx.serialization.internal/SerializerFactory, org.ton.tlb/TlbNegatedCodec<org.ton.hashmap/Unary> { // org.ton.hashmap/Unary.Companion|null[0]
        final fun createCell(org.ton.hashmap/Unary): org.ton.cell/Cell // org.ton.hashmap/Unary.Companion.createCell|createCell(org.ton.hashmap.Unary){}[0]
        final fun loadNegatedTlb(org.ton.cell/Cell): org.ton.tlb/TlbNegatedResult<org.ton.hashmap/Unary> // org.ton.hashmap/Unary.Companion.loadNegatedTlb|loadNegatedTlb(org.ton.cell.Cell){}[0]
        final fun loadNegatedTlb(org.ton.cell/CellSlice): org.ton.tlb/TlbNegatedResult<org.ton.hashmap/Unary> // org.ton.hashmap/Unary.Companion.loadNegatedTlb|loadNegatedTlb(org.ton.cell.CellSlice){}[0]
        final fun loadTlb(org.ton.cell/Cell): org.ton.hashmap/Unary // org.ton.hashmap/Unary.Companion.loadTlb|loadTlb(org.ton.cell.Cell){}[0]
        final fun loadTlb(org.ton.cell/CellSlice): org.ton.hashmap/Unary // org.ton.hashmap/Unary.Companion.loadTlb|loadTlb(org.ton.cell.CellSlice){}[0]
        final fun loadTlb(org.ton.cell/CellSlice, org.ton.kotlin.cell/CellContext): org.ton.hashmap/Unary // org.ton.hashmap/Unary.Companion.loadTlb|loadTlb(org.ton.cell.CellSlice;org.ton.kotlin.cell.CellContext){}[0]
        final fun of(kotlin/Int): org.ton.hashmap/Unary // org.ton.hashmap/Unary.Companion.of|of(kotlin.Int){}[0]
        final fun serializer(): kotlinx.serialization/KSerializer<org.ton.hashmap/Unary> // org.ton.hashmap/Unary.Companion.serializer|serializer(){}[0]
        final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/Unary.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
        final fun storeNegatedTlb(org.ton.cell/CellBuilder, org.ton.hashmap/Unary): kotlin/Int // org.ton.hashmap/Unary.Companion.storeNegatedTlb|storeNegatedTlb(org.ton.cell.CellBuilder;org.ton.hashmap.Unary){}[0]
        final fun storeTlb(org.ton.cell/CellBuilder, org.ton.hashmap/Unary) // org.ton.hashmap/Unary.Companion.storeTlb|storeTlb(org.ton.cell.CellBuilder;org.ton.hashmap.Unary){}[0]
        final fun storeTlb(org.ton.cell/CellBuilder, org.ton.hashmap/Unary, org.ton.kotlin.cell/CellContext) // org.ton.hashmap/Unary.Companion.storeTlb|storeTlb(org.ton.cell.CellBuilder;org.ton.hashmap.Unary;org.ton.kotlin.cell.CellContext){}[0]
        final fun tlbCodec(): org.ton.tlb/TlbNegatedCodec<org.ton.hashmap/Unary> // org.ton.hashmap/Unary.Companion.tlbCodec|tlbCodec(){}[0]
    }
}

final object org.ton.hashmap/UnaryZero : kotlinx.serialization.internal/SerializerFactory, org.ton.hashmap/Unary { // org.ton.hashmap/UnaryZero|null[0]
    final fun print(org.ton.tlb/TlbPrettyPrinter): org.ton.tlb/TlbPrettyPrinter // org.ton.hashmap/UnaryZero.print|print(org.ton.tlb.TlbPrettyPrinter){}[0]
    final fun serializer(): kotlinx.serialization/KSerializer<org.ton.hashmap/UnaryZero> // org.ton.hashmap/UnaryZero.serializer|serializer(){}[0]
    final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // org.ton.hashmap/UnaryZero.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
    final fun toString(): kotlin/String // org.ton.hashmap/UnaryZero.toString|toString(){}[0]
}

final inline fun org.ton.hashmap/HmLabel(org.ton.bitstring/BitString, kotlin/Int = ...): org.ton.hashmap/HmLabel // org.ton.hashmap/HmLabel|HmLabel(org.ton.bitstring.BitString;kotlin.Int){}[0]
final inline fun org.ton.hashmap/Unary(kotlin/Int): org.ton.hashmap/Unary // org.ton.hashmap/Unary|Unary(kotlin.Int){}[0]
