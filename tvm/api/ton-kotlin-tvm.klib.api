// Klib ABI Dump
// Targets: [iosArm64, iosSimulatorArm64, iosX64, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, watchosArm32, watchosArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <org.ton.kotlin:ton-kotlin-tvm>
final enum class org.ton.cell/CellType : kotlin/Enum<org.ton.cell/CellType> { // org.ton.cell/CellType|null[0]
    enum entry LIBRARY_REFERENCE // org.ton.cell/CellType.LIBRARY_REFERENCE|null[0]
    enum entry MERKLE_PROOF // org.ton.cell/CellType.MERKLE_PROOF|null[0]
    enum entry MERKLE_UPDATE // org.ton.cell/CellType.MERKLE_UPDATE|null[0]
    enum entry ORDINARY // org.ton.cell/CellType.ORDINARY|null[0]
    enum entry PRUNED_BRANCH // org.ton.cell/CellType.PRUNED_BRANCH|null[0]

    final val entries // org.ton.cell/CellType.entries|#static{}entries[0]
        final fun <get-entries>(): kotlin.enums/EnumEntries<org.ton.cell/CellType> // org.ton.cell/CellType.entries.<get-entries>|<get-entries>#static(){}[0]
    final val isExotic // org.ton.cell/CellType.isExotic|{}isExotic[0]
        final fun <get-isExotic>(): kotlin/Boolean // org.ton.cell/CellType.isExotic.<get-isExotic>|<get-isExotic>(){}[0]
    final val isMerkle // org.ton.cell/CellType.isMerkle|{}isMerkle[0]
        final fun <get-isMerkle>(): kotlin/Boolean // org.ton.cell/CellType.isMerkle.<get-isMerkle>|<get-isMerkle>(){}[0]
    final val isPruned // org.ton.cell/CellType.isPruned|{}isPruned[0]
        final fun <get-isPruned>(): kotlin/Boolean // org.ton.cell/CellType.isPruned.<get-isPruned>|<get-isPruned>(){}[0]
    final val value // org.ton.cell/CellType.value|{}value[0]
        final fun <get-value>(): kotlin/Int // org.ton.cell/CellType.value.<get-value>|<get-value>(){}[0]

    final fun valueOf(kotlin/String): org.ton.cell/CellType // org.ton.cell/CellType.valueOf|valueOf#static(kotlin.String){}[0]
    final fun values(): kotlin/Array<org.ton.cell/CellType> // org.ton.cell/CellType.values|values#static(){}[0]

    final object Companion { // org.ton.cell/CellType.Companion|null[0]
        final fun get(kotlin/Int): org.ton.cell/CellType // org.ton.cell/CellType.Companion.get|get(kotlin.Int){}[0]
    }
}

abstract interface org.ton.boc/BagOfCells : kotlin.collections/Iterable<org.ton.cell/Cell> { // org.ton.boc/BagOfCells|null[0]
    abstract val roots // org.ton.boc/BagOfCells.roots|{}roots[0]
        abstract fun <get-roots>(): kotlin.collections/List<org.ton.cell/Cell> // org.ton.boc/BagOfCells.roots.<get-roots>|<get-roots>(){}[0]

    abstract fun toString(): kotlin/String // org.ton.boc/BagOfCells.toString|toString(){}[0]
    open fun toByteArray(): kotlin/ByteArray // org.ton.boc/BagOfCells.toByteArray|toByteArray(){}[0]
    open fun write(kotlinx.io/Sink) // org.ton.boc/BagOfCells.write|write(kotlinx.io.Sink){}[0]

    final object Companion { // org.ton.boc/BagOfCells.Companion|null[0]
        final const val BOC_GENERIC_MAGIC // org.ton.boc/BagOfCells.Companion.BOC_GENERIC_MAGIC|{}BOC_GENERIC_MAGIC[0]
            final fun <get-BOC_GENERIC_MAGIC>(): kotlin/Int // org.ton.boc/BagOfCells.Companion.BOC_GENERIC_MAGIC.<get-BOC_GENERIC_MAGIC>|<get-BOC_GENERIC_MAGIC>(){}[0]
        final const val BOC_INDEXED_CRC32C_MAGIC // org.ton.boc/BagOfCells.Companion.BOC_INDEXED_CRC32C_MAGIC|{}BOC_INDEXED_CRC32C_MAGIC[0]
            final fun <get-BOC_INDEXED_CRC32C_MAGIC>(): kotlin/Int // org.ton.boc/BagOfCells.Companion.BOC_INDEXED_CRC32C_MAGIC.<get-BOC_INDEXED_CRC32C_MAGIC>|<get-BOC_INDEXED_CRC32C_MAGIC>(){}[0]
        final const val BOC_INDEXED_MAGIC // org.ton.boc/BagOfCells.Companion.BOC_INDEXED_MAGIC|{}BOC_INDEXED_MAGIC[0]
            final fun <get-BOC_INDEXED_MAGIC>(): kotlin/Int // org.ton.boc/BagOfCells.Companion.BOC_INDEXED_MAGIC.<get-BOC_INDEXED_MAGIC>|<get-BOC_INDEXED_MAGIC>(){}[0]

        final fun of(kotlin.collections/Iterable<org.ton.cell/Cell>): org.ton.boc/BagOfCells // org.ton.boc/BagOfCells.Companion.of|of(kotlin.collections.Iterable<org.ton.cell.Cell>){}[0]
        final fun of(kotlin/Array<out org.ton.cell/Cell>...): org.ton.boc/BagOfCells // org.ton.boc/BagOfCells.Companion.of|of(kotlin.Array<out|org.ton.cell.Cell>...){}[0]
        final fun of(kotlin/ByteArray): org.ton.boc/BagOfCells // org.ton.boc/BagOfCells.Companion.of|of(kotlin.ByteArray){}[0]
        final fun read(kotlinx.io/Source): org.ton.boc/BagOfCells // org.ton.boc/BagOfCells.Companion.read|read(kotlinx.io.Source){}[0]
    }
}

abstract interface org.ton.cell/Cell { // org.ton.cell/Cell|null[0]
    abstract val bits // org.ton.cell/Cell.bits|{}bits[0]
        abstract fun <get-bits>(): org.ton.bitstring/BitString // org.ton.cell/Cell.bits.<get-bits>|<get-bits>(){}[0]
    abstract val descriptor // org.ton.cell/Cell.descriptor|{}descriptor[0]
        abstract fun <get-descriptor>(): org.ton.cell/CellDescriptor // org.ton.cell/Cell.descriptor.<get-descriptor>|<get-descriptor>(){}[0]
    abstract val refs // org.ton.cell/Cell.refs|{}refs[0]
        abstract fun <get-refs>(): kotlin.collections/List<org.ton.cell/Cell> // org.ton.cell/Cell.refs.<get-refs>|<get-refs>(){}[0]
    open val levelMask // org.ton.cell/Cell.levelMask|{}levelMask[0]
        open fun <get-levelMask>(): org.ton.cell/LevelMask // org.ton.cell/Cell.levelMask.<get-levelMask>|<get-levelMask>(){}[0]
    open val type // org.ton.cell/Cell.type|{}type[0]
        open fun <get-type>(): org.ton.cell/CellType // org.ton.cell/Cell.type.<get-type>|<get-type>(){}[0]

    abstract fun depth(kotlin/Int = ...): kotlin/Int // org.ton.cell/Cell.depth|depth(kotlin.Int){}[0]
    abstract fun hash(kotlin/Int = ...): org.ton.bitstring/BitString // org.ton.cell/Cell.hash|hash(kotlin.Int){}[0]
    abstract fun toString(): kotlin/String // org.ton.cell/Cell.toString|toString(){}[0]
    abstract fun virtualize(kotlin/Int = ...): org.ton.cell/Cell // org.ton.cell/Cell.virtualize|virtualize(kotlin.Int){}[0]
    open fun <#A1: kotlin/Any?> parse(kotlin/Function1<org.ton.cell/CellSlice, #A1>): #A1 // org.ton.cell/Cell.parse|parse(kotlin.Function1<org.ton.cell.CellSlice,0:0>){0ยง<kotlin.Any?>}[0]
    open fun beginParse(): org.ton.cell/CellSlice // org.ton.cell/Cell.beginParse|beginParse(){}[0]
    open fun isEmpty(): kotlin/Boolean // org.ton.cell/Cell.isEmpty|isEmpty(){}[0]
    open fun treeWalk(): kotlin.sequences/Sequence<org.ton.cell/Cell> // org.ton.cell/Cell.treeWalk|treeWalk(){}[0]

    final object Companion { // org.ton.cell/Cell.Companion|null[0]
        final const val DEPTH_BITS // org.ton.cell/Cell.Companion.DEPTH_BITS|{}DEPTH_BITS[0]
            final fun <get-DEPTH_BITS>(): kotlin/Int // org.ton.cell/Cell.Companion.DEPTH_BITS.<get-DEPTH_BITS>|<get-DEPTH_BITS>(){}[0]
        final const val DEPTH_BYTES // org.ton.cell/Cell.Companion.DEPTH_BYTES|{}DEPTH_BYTES[0]
            final fun <get-DEPTH_BYTES>(): kotlin/Int // org.ton.cell/Cell.Companion.DEPTH_BYTES.<get-DEPTH_BYTES>|<get-DEPTH_BYTES>(){}[0]
        final const val HASH_BITS // org.ton.cell/Cell.Companion.HASH_BITS|{}HASH_BITS[0]
            final fun <get-HASH_BITS>(): kotlin/Int // org.ton.cell/Cell.Companion.HASH_BITS.<get-HASH_BITS>|<get-HASH_BITS>(){}[0]
        final const val HASH_BYTES // org.ton.cell/Cell.Companion.HASH_BYTES|{}HASH_BYTES[0]
            final fun <get-HASH_BYTES>(): kotlin/Int // org.ton.cell/Cell.Companion.HASH_BYTES.<get-HASH_BYTES>|<get-HASH_BYTES>(){}[0]
        final const val MAX_BITS_SIZE // org.ton.cell/Cell.Companion.MAX_BITS_SIZE|{}MAX_BITS_SIZE[0]
            final fun <get-MAX_BITS_SIZE>(): kotlin/Int // org.ton.cell/Cell.Companion.MAX_BITS_SIZE.<get-MAX_BITS_SIZE>|<get-MAX_BITS_SIZE>(){}[0]
        final const val MAX_DEPTH // org.ton.cell/Cell.Companion.MAX_DEPTH|{}MAX_DEPTH[0]
            final fun <get-MAX_DEPTH>(): kotlin/Int // org.ton.cell/Cell.Companion.MAX_DEPTH.<get-MAX_DEPTH>|<get-MAX_DEPTH>(){}[0]
        final const val MAX_LEVEL // org.ton.cell/Cell.Companion.MAX_LEVEL|{}MAX_LEVEL[0]
            final fun <get-MAX_LEVEL>(): kotlin/Int // org.ton.cell/Cell.Companion.MAX_LEVEL.<get-MAX_LEVEL>|<get-MAX_LEVEL>(){}[0]

        final fun empty(): org.ton.cell/Cell // org.ton.cell/Cell.Companion.empty|empty(){}[0]
        final fun getBitsDescriptor(org.ton.bitstring/BitString): kotlin/Byte // org.ton.cell/Cell.Companion.getBitsDescriptor|getBitsDescriptor(org.ton.bitstring.BitString){}[0]
        final fun getRefsDescriptor(kotlin/Int, kotlin/Boolean, org.ton.cell/LevelMask): kotlin/Byte // org.ton.cell/Cell.Companion.getRefsDescriptor|getRefsDescriptor(kotlin.Int;kotlin.Boolean;org.ton.cell.LevelMask){}[0]
        final fun of(kotlin/String, kotlin/Array<out org.ton.cell/Cell>...): org.ton.cell/Cell // org.ton.cell/Cell.Companion.of|of(kotlin.String;kotlin.Array<out|org.ton.cell.Cell>...){}[0]
        final fun of(org.ton.bitstring/BitString, kotlin/Array<out org.ton.cell/Cell>...): org.ton.cell/Cell // org.ton.cell/Cell.Companion.of|of(org.ton.bitstring.BitString;kotlin.Array<out|org.ton.cell.Cell>...){}[0]
        final fun toString(org.ton.cell/Cell): kotlin/String // org.ton.cell/Cell.Companion.toString|toString(org.ton.cell.Cell){}[0]
        final fun toString(org.ton.cell/Cell, kotlin.text/Appendable, kotlin/String = ...) // org.ton.cell/Cell.Companion.toString|toString(org.ton.cell.Cell;kotlin.text.Appendable;kotlin.String){}[0]
    }
}

abstract interface org.ton.cell/CellBuilder { // org.ton.cell/CellBuilder|null[0]
    abstract val bitsPosition // org.ton.cell/CellBuilder.bitsPosition|{}bitsPosition[0]
        abstract fun <get-bitsPosition>(): kotlin/Int // org.ton.cell/CellBuilder.bitsPosition.<get-bitsPosition>|<get-bitsPosition>(){}[0]
    abstract val remainingBits // org.ton.cell/CellBuilder.remainingBits|{}remainingBits[0]
        abstract fun <get-remainingBits>(): kotlin/Int // org.ton.cell/CellBuilder.remainingBits.<get-remainingBits>|<get-remainingBits>(){}[0]

    abstract var bits // org.ton.cell/CellBuilder.bits|{}bits[0]
        abstract fun <get-bits>(): org.ton.bitstring/MutableBitString // org.ton.cell/CellBuilder.bits.<get-bits>|<get-bits>(){}[0]
        abstract fun <set-bits>(org.ton.bitstring/MutableBitString) // org.ton.cell/CellBuilder.bits.<set-bits>|<set-bits>(org.ton.bitstring.MutableBitString){}[0]
    abstract var isExotic // org.ton.cell/CellBuilder.isExotic|{}isExotic[0]
        abstract fun <get-isExotic>(): kotlin/Boolean // org.ton.cell/CellBuilder.isExotic.<get-isExotic>|<get-isExotic>(){}[0]
        abstract fun <set-isExotic>(kotlin/Boolean) // org.ton.cell/CellBuilder.isExotic.<set-isExotic>|<set-isExotic>(kotlin.Boolean){}[0]
    abstract var levelMask // org.ton.cell/CellBuilder.levelMask|{}levelMask[0]
        abstract fun <get-levelMask>(): org.ton.cell/LevelMask? // org.ton.cell/CellBuilder.levelMask.<get-levelMask>|<get-levelMask>(){}[0]
        abstract fun <set-levelMask>(org.ton.cell/LevelMask?) // org.ton.cell/CellBuilder.levelMask.<set-levelMask>|<set-levelMask>(org.ton.cell.LevelMask?){}[0]
    abstract var refs // org.ton.cell/CellBuilder.refs|{}refs[0]
        abstract fun <get-refs>(): kotlin.collections/MutableList<org.ton.cell/Cell> // org.ton.cell/CellBuilder.refs.<get-refs>|<get-refs>(){}[0]
        abstract fun <set-refs>(kotlin.collections/MutableList<org.ton.cell/Cell>) // org.ton.cell/CellBuilder.refs.<set-refs>|<set-refs>(kotlin.collections.MutableList<org.ton.cell.Cell>){}[0]

    abstract fun build(): org.ton.cell/Cell // org.ton.cell/CellBuilder.build|build(){}[0]
    abstract fun reset(): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.reset|reset(){}[0]
    abstract fun storeBitString(org.ton.bitstring/BitString, kotlin/Int = ..., kotlin/Int = ...): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBitString|storeBitString(org.ton.bitstring.BitString;kotlin.Int;kotlin.Int){}[0]
    abstract fun storeBits(kotlin.collections/Collection<kotlin/Boolean>): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBits|storeBits(kotlin.collections.Collection<kotlin.Boolean>){}[0]
    abstract fun storeBits(kotlin.collections/Iterable<kotlin/Boolean>): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBits|storeBits(kotlin.collections.Iterable<kotlin.Boolean>){}[0]
    abstract fun storeBits(kotlin/BooleanArray...): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBits|storeBits(kotlin.BooleanArray...){}[0]
    abstract fun storeBits(kotlin/ByteArray, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBits|storeBits(kotlin.ByteArray;kotlin.Int){}[0]
    abstract fun storeBoolean(kotlin/Boolean): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBoolean|storeBoolean(kotlin.Boolean){}[0]
    abstract fun storeByte(kotlin/Byte): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeByte|storeByte(kotlin.Byte){}[0]
    abstract fun storeByteString(kotlinx.io.bytestring/ByteString): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeByteString|storeByteString(kotlinx.io.bytestring.ByteString){}[0]
    abstract fun storeBytes(kotlin/ByteArray): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBytes|storeBytes(kotlin.ByteArray){}[0]
    abstract fun storeInt(org.ton.bigint/BigInt, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeInt|storeInt(org.ton.bigint.BigInt;kotlin.Int){}[0]
    abstract fun storeNullableRef(org.ton.cell/Cell?): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeNullableRef|storeNullableRef(org.ton.cell.Cell?){}[0]
    abstract fun storeRef(org.ton.cell/Cell): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeRef|storeRef(org.ton.cell.Cell){}[0]
    abstract fun storeRefs(kotlin.collections/Collection<org.ton.cell/Cell>): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeRefs|storeRefs(kotlin.collections.Collection<org.ton.cell.Cell>){}[0]
    abstract fun storeRefs(kotlin.collections/Iterable<org.ton.cell/Cell>): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeRefs|storeRefs(kotlin.collections.Iterable<org.ton.cell.Cell>){}[0]
    abstract fun storeRefs(kotlin/Array<out org.ton.cell/Cell>...): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeRefs|storeRefs(kotlin.Array<out|org.ton.cell.Cell>...){}[0]
    abstract fun storeSlice(org.ton.cell/CellSlice): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeSlice|storeSlice(org.ton.cell.CellSlice){}[0]
    abstract fun storeUInt(org.ton.bigint/BigInt, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt|storeUInt(org.ton.bigint.BigInt;kotlin.Int){}[0]
    open fun endCell(): org.ton.cell/Cell // org.ton.cell/CellBuilder.endCell|endCell(){}[0]
    open fun storeBit(kotlin/Boolean): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBit|storeBit(kotlin.Boolean){}[0]
    open fun storeBits(org.ton.bitstring/BitString): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBits|storeBits(org.ton.bitstring.BitString){}[0]
    open fun storeBytes(kotlin/ByteArray, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeBytes|storeBytes(kotlin.ByteArray;kotlin.Int){}[0]
    open fun storeInt(kotlin/Byte, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeInt|storeInt(kotlin.Byte;kotlin.Int){}[0]
    open fun storeInt(kotlin/Int, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeInt|storeInt(kotlin.Int;kotlin.Int){}[0]
    open fun storeInt(kotlin/Long, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeInt|storeInt(kotlin.Long;kotlin.Int){}[0]
    open fun storeInt(kotlin/Short, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeInt|storeInt(kotlin.Short;kotlin.Int){}[0]
    open fun storeLong(kotlin/Long, kotlin/Int = ...): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeLong|storeLong(kotlin.Long;kotlin.Int){}[0]
    open fun storeUInt(kotlin/Byte, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt|storeUInt(kotlin.Byte;kotlin.Int){}[0]
    open fun storeUInt(kotlin/Int, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt|storeUInt(kotlin.Int;kotlin.Int){}[0]
    open fun storeUInt(kotlin/Long, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt|storeUInt(kotlin.Long;kotlin.Int){}[0]
    open fun storeUInt(kotlin/Short, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt|storeUInt(kotlin.Short;kotlin.Int){}[0]
    open fun storeUInt16(kotlin/UShort): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt16|storeUInt16(kotlin.UShort){}[0]
    open fun storeUInt32(kotlin/UInt): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt32|storeUInt32(kotlin.UInt){}[0]
    open fun storeUInt64(kotlin/ULong): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt64|storeUInt64(kotlin.ULong){}[0]
    open fun storeUInt8(kotlin/UByte): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUInt8|storeUInt8(kotlin.UByte){}[0]
    open fun storeUIntLeq(kotlin/Byte, kotlin/Byte): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLeq|storeUIntLeq(kotlin.Byte;kotlin.Byte){}[0]
    open fun storeUIntLeq(kotlin/Int, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLeq|storeUIntLeq(kotlin.Int;kotlin.Int){}[0]
    open fun storeUIntLeq(kotlin/Long, kotlin/Long): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLeq|storeUIntLeq(kotlin.Long;kotlin.Long){}[0]
    open fun storeUIntLeq(kotlin/Short, kotlin/Short): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLeq|storeUIntLeq(kotlin.Short;kotlin.Short){}[0]
    open fun storeUIntLeq(org.ton.bigint/BigInt, org.ton.bigint/BigInt): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLeq|storeUIntLeq(org.ton.bigint.BigInt;org.ton.bigint.BigInt){}[0]
    open fun storeUIntLes(kotlin/Byte, kotlin/Byte): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLes|storeUIntLes(kotlin.Byte;kotlin.Byte){}[0]
    open fun storeUIntLes(kotlin/Int, kotlin/Int): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLes|storeUIntLes(kotlin.Int;kotlin.Int){}[0]
    open fun storeUIntLes(kotlin/Long, kotlin/Long): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLes|storeUIntLes(kotlin.Long;kotlin.Long){}[0]
    open fun storeUIntLes(kotlin/Short, kotlin/Short): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLes|storeUIntLes(kotlin.Short;kotlin.Short){}[0]
    open fun storeUIntLes(org.ton.bigint/BigInt, org.ton.bigint/BigInt): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeUIntLes|storeUIntLes(org.ton.bigint.BigInt;org.ton.bigint.BigInt){}[0]
    open fun storeULong(kotlin/ULong, kotlin/Int = ...): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.storeULong|storeULong(kotlin.ULong;kotlin.Int){}[0]

    final object Companion { // org.ton.cell/CellBuilder.Companion|null[0]
        final fun beginCell(): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.Companion.beginCell|beginCell(){}[0]
        final fun createCell(kotlin/Function1<org.ton.cell/CellBuilder, kotlin/Unit>): org.ton.cell/Cell // org.ton.cell/CellBuilder.Companion.createCell|createCell(kotlin.Function1<org.ton.cell.CellBuilder,kotlin.Unit>){}[0]
        final fun createPrunedBranch(org.ton.cell/Cell, kotlin/Int): org.ton.cell/Cell // org.ton.cell/CellBuilder.Companion.createPrunedBranch|createPrunedBranch(org.ton.cell.Cell;kotlin.Int){}[0]
        final fun of(org.ton.cell/Cell): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder.Companion.of|of(org.ton.cell.Cell){}[0]
    }
}

abstract interface org.ton.cell/CellDescriptor { // org.ton.cell/CellDescriptor|null[0]
    abstract val cellType // org.ton.cell/CellDescriptor.cellType|{}cellType[0]
        abstract fun <get-cellType>(): org.ton.cell/CellType // org.ton.cell/CellDescriptor.cellType.<get-cellType>|<get-cellType>(){}[0]
    abstract val d1 // org.ton.cell/CellDescriptor.d1|{}d1[0]
        abstract fun <get-d1>(): kotlin/Byte // org.ton.cell/CellDescriptor.d1.<get-d1>|<get-d1>(){}[0]
    abstract val d2 // org.ton.cell/CellDescriptor.d2|{}d2[0]
        abstract fun <get-d2>(): kotlin/Byte // org.ton.cell/CellDescriptor.d2.<get-d2>|<get-d2>(){}[0]
    abstract val dataLength // org.ton.cell/CellDescriptor.dataLength|{}dataLength[0]
        abstract fun <get-dataLength>(): kotlin/Int // org.ton.cell/CellDescriptor.dataLength.<get-dataLength>|<get-dataLength>(){}[0]
    abstract val hasHashes // org.ton.cell/CellDescriptor.hasHashes|{}hasHashes[0]
        abstract fun <get-hasHashes>(): kotlin/Boolean // org.ton.cell/CellDescriptor.hasHashes.<get-hasHashes>|<get-hasHashes>(){}[0]
    abstract val hashCount // org.ton.cell/CellDescriptor.hashCount|{}hashCount[0]
        abstract fun <get-hashCount>(): kotlin/Int // org.ton.cell/CellDescriptor.hashCount.<get-hashCount>|<get-hashCount>(){}[0]
    abstract val isAbsent // org.ton.cell/CellDescriptor.isAbsent|{}isAbsent[0]
        abstract fun <get-isAbsent>(): kotlin/Boolean // org.ton.cell/CellDescriptor.isAbsent.<get-isAbsent>|<get-isAbsent>(){}[0]
    abstract val isAligned // org.ton.cell/CellDescriptor.isAligned|{}isAligned[0]
        abstract fun <get-isAligned>(): kotlin/Boolean // org.ton.cell/CellDescriptor.isAligned.<get-isAligned>|<get-isAligned>(){}[0]
    abstract val isExotic // org.ton.cell/CellDescriptor.isExotic|{}isExotic[0]
        abstract fun <get-isExotic>(): kotlin/Boolean // org.ton.cell/CellDescriptor.isExotic.<get-isExotic>|<get-isExotic>(){}[0]
    abstract val levelMask // org.ton.cell/CellDescriptor.levelMask|{}levelMask[0]
        abstract fun <get-levelMask>(): org.ton.cell/LevelMask // org.ton.cell/CellDescriptor.levelMask.<get-levelMask>|<get-levelMask>(){}[0]
    abstract val referenceCount // org.ton.cell/CellDescriptor.referenceCount|{}referenceCount[0]
        abstract fun <get-referenceCount>(): kotlin/Int // org.ton.cell/CellDescriptor.referenceCount.<get-referenceCount>|<get-referenceCount>(){}[0]

    open fun component1(): kotlin/Byte // org.ton.cell/CellDescriptor.component1|component1(){}[0]
    open fun component2(): kotlin/Byte // org.ton.cell/CellDescriptor.component2|component2(){}[0]

    final object Companion { // org.ton.cell/CellDescriptor.Companion|null[0]
        final const val HAS_HASHES_MASK // org.ton.cell/CellDescriptor.Companion.HAS_HASHES_MASK|{}HAS_HASHES_MASK[0]
            final fun <get-HAS_HASHES_MASK>(): kotlin/Int // org.ton.cell/CellDescriptor.Companion.HAS_HASHES_MASK.<get-HAS_HASHES_MASK>|<get-HAS_HASHES_MASK>(){}[0]
        final const val IS_EXOTIC_MASK // org.ton.cell/CellDescriptor.Companion.IS_EXOTIC_MASK|{}IS_EXOTIC_MASK[0]
            final fun <get-IS_EXOTIC_MASK>(): kotlin/Int // org.ton.cell/CellDescriptor.Companion.IS_EXOTIC_MASK.<get-IS_EXOTIC_MASK>|<get-IS_EXOTIC_MASK>(){}[0]
        final const val LEVEL_MASK // org.ton.cell/CellDescriptor.Companion.LEVEL_MASK|{}LEVEL_MASK[0]
            final fun <get-LEVEL_MASK>(): kotlin/Int // org.ton.cell/CellDescriptor.Companion.LEVEL_MASK.<get-LEVEL_MASK>|<get-LEVEL_MASK>(){}[0]
        final const val REFERENCE_COUNT_MASK // org.ton.cell/CellDescriptor.Companion.REFERENCE_COUNT_MASK|{}REFERENCE_COUNT_MASK[0]
            final fun <get-REFERENCE_COUNT_MASK>(): kotlin/Int // org.ton.cell/CellDescriptor.Companion.REFERENCE_COUNT_MASK.<get-REFERENCE_COUNT_MASK>|<get-REFERENCE_COUNT_MASK>(){}[0]

        final fun computeD1(org.ton.cell/LevelMask, kotlin/Boolean, kotlin/Int): kotlin/Byte // org.ton.cell/CellDescriptor.Companion.computeD1|computeD1(org.ton.cell.LevelMask;kotlin.Boolean;kotlin.Int){}[0]
        final fun computeD2(kotlin/Int): kotlin/Byte // org.ton.cell/CellDescriptor.Companion.computeD2|computeD2(kotlin.Int){}[0]
        final fun from(org.ton.cell/LevelMask, kotlin/Boolean, kotlin/Int, kotlin/Int): org.ton.cell/CellDescriptor // org.ton.cell/CellDescriptor.Companion.from|from(org.ton.cell.LevelMask;kotlin.Boolean;kotlin.Int;kotlin.Int){}[0]
        final fun fromBytes(kotlin/Byte, kotlin/Byte): org.ton.cell/CellDescriptor // org.ton.cell/CellDescriptor.Companion.fromBytes|fromBytes(kotlin.Byte;kotlin.Byte){}[0]
        final fun fromBytes(kotlin/ByteArray): org.ton.cell/CellDescriptor // org.ton.cell/CellDescriptor.Companion.fromBytes|fromBytes(kotlin.ByteArray){}[0]
        final fun fromBytes(kotlin/ByteArray, kotlin/Int): org.ton.cell/CellDescriptor // org.ton.cell/CellDescriptor.Companion.fromBytes|fromBytes(kotlin.ByteArray;kotlin.Int){}[0]
    }
}

abstract interface org.ton.cell/CellSlice { // org.ton.cell/CellSlice|null[0]
    abstract val bits // org.ton.cell/CellSlice.bits|{}bits[0]
        abstract fun <get-bits>(): org.ton.bitstring/BitString // org.ton.cell/CellSlice.bits.<get-bits>|<get-bits>(){}[0]
    abstract val refs // org.ton.cell/CellSlice.refs|{}refs[0]
        abstract fun <get-refs>(): kotlin.collections/List<org.ton.cell/Cell> // org.ton.cell/CellSlice.refs.<get-refs>|<get-refs>(){}[0]
    open val remainingBits // org.ton.cell/CellSlice.remainingBits|{}remainingBits[0]
        open fun <get-remainingBits>(): kotlin/Int // org.ton.cell/CellSlice.remainingBits.<get-remainingBits>|<get-remainingBits>(){}[0]
    open val remainingRefs // org.ton.cell/CellSlice.remainingRefs|{}remainingRefs[0]
        open fun <get-remainingRefs>(): kotlin/Int // org.ton.cell/CellSlice.remainingRefs.<get-remainingRefs>|<get-remainingRefs>(){}[0]

    abstract var bitsPosition // org.ton.cell/CellSlice.bitsPosition|{}bitsPosition[0]
        abstract fun <get-bitsPosition>(): kotlin/Int // org.ton.cell/CellSlice.bitsPosition.<get-bitsPosition>|<get-bitsPosition>(){}[0]
        abstract fun <set-bitsPosition>(kotlin/Int) // org.ton.cell/CellSlice.bitsPosition.<set-bitsPosition>|<set-bitsPosition>(kotlin.Int){}[0]
    abstract var refsPosition // org.ton.cell/CellSlice.refsPosition|{}refsPosition[0]
        abstract fun <get-refsPosition>(): kotlin/Int // org.ton.cell/CellSlice.refsPosition.<get-refsPosition>|<get-refsPosition>(){}[0]
        abstract fun <set-refsPosition>(kotlin/Int) // org.ton.cell/CellSlice.refsPosition.<set-refsPosition>|<set-refsPosition>(kotlin.Int){}[0]

    abstract fun <#A1: kotlin/Any?> preloadRef(kotlin/Function1<org.ton.cell/CellSlice, #A1>): #A1 // org.ton.cell/CellSlice.preloadRef|preloadRef(kotlin.Function1<org.ton.cell.CellSlice,0:0>){0ยง<kotlin.Any?>}[0]
    abstract fun endParse() // org.ton.cell/CellSlice.endParse|endParse(){}[0]
    abstract fun loadBitString(kotlin/Int): org.ton.bitstring/BitString // org.ton.cell/CellSlice.loadBitString|loadBitString(kotlin.Int){}[0]
    abstract fun loadBoolean(): kotlin/Boolean // org.ton.cell/CellSlice.loadBoolean|loadBoolean(){}[0]
    abstract fun loadByteArray(kotlin/Int): kotlin/ByteArray // org.ton.cell/CellSlice.loadByteArray|loadByteArray(kotlin.Int){}[0]
    abstract fun loadInt(kotlin/Int): org.ton.bigint/BigInt // org.ton.cell/CellSlice.loadInt|loadInt(kotlin.Int){}[0]
    abstract fun loadNullableRef(): org.ton.cell/Cell? // org.ton.cell/CellSlice.loadNullableRef|loadNullableRef(){}[0]
    abstract fun loadRef(): org.ton.cell/Cell // org.ton.cell/CellSlice.loadRef|loadRef(){}[0]
    abstract fun loadRefs(kotlin/Int): kotlin.collections/List<org.ton.cell/Cell> // org.ton.cell/CellSlice.loadRefs|loadRefs(kotlin.Int){}[0]
    abstract fun loadUInt(kotlin/Int): org.ton.bigint/BigInt // org.ton.cell/CellSlice.loadUInt|loadUInt(kotlin.Int){}[0]
    abstract fun preloadBitString(kotlin/Int): org.ton.bitstring/BitString // org.ton.cell/CellSlice.preloadBitString|preloadBitString(kotlin.Int){}[0]
    abstract fun preloadBoolean(): kotlin/Boolean // org.ton.cell/CellSlice.preloadBoolean|preloadBoolean(){}[0]
    abstract fun preloadByteArray(kotlin/Int): kotlin/ByteArray // org.ton.cell/CellSlice.preloadByteArray|preloadByteArray(kotlin.Int){}[0]
    abstract fun preloadRef(): org.ton.cell/Cell // org.ton.cell/CellSlice.preloadRef|preloadRef(){}[0]
    abstract fun preloadRef(kotlin/Int): org.ton.cell/Cell // org.ton.cell/CellSlice.preloadRef|preloadRef(kotlin.Int){}[0]
    abstract fun preloadRefs(kotlin/Int): kotlin.collections/List<org.ton.cell/Cell> // org.ton.cell/CellSlice.preloadRefs|preloadRefs(kotlin.Int){}[0]
    abstract fun skipBits(kotlin/Int): org.ton.cell/CellSlice // org.ton.cell/CellSlice.skipBits|skipBits(kotlin.Int){}[0]
    open fun component1(): org.ton.bitstring/BitString // org.ton.cell/CellSlice.component1|component1(){}[0]
    open fun component2(): kotlin.collections/List<org.ton.cell/Cell> // org.ton.cell/CellSlice.component2|component2(){}[0]
    open fun countLeadingBits(kotlin/Boolean): kotlin/Int // org.ton.cell/CellSlice.countLeadingBits|countLeadingBits(kotlin.Boolean){}[0]
    open fun isEmpty(): kotlin/Boolean // org.ton.cell/CellSlice.isEmpty|isEmpty(){}[0]
    open fun loadBit(): kotlin/Boolean // org.ton.cell/CellSlice.loadBit|loadBit(){}[0]
    open fun loadBits(kotlin/Int): org.ton.bitstring/BitString // org.ton.cell/CellSlice.loadBits|loadBits(kotlin.Int){}[0]
    open fun loadByteString(kotlin/Int): kotlinx.io.bytestring/ByteString // org.ton.cell/CellSlice.loadByteString|loadByteString(kotlin.Int){}[0]
    open fun loadLong(kotlin/Int = ...): kotlin/Long // org.ton.cell/CellSlice.loadLong|loadLong(kotlin.Int){}[0]
    open fun loadTinyInt(kotlin/Int): kotlin/Long // org.ton.cell/CellSlice.loadTinyInt|loadTinyInt(kotlin.Int){}[0]
    open fun loadUInt16(): kotlin/UShort // org.ton.cell/CellSlice.loadUInt16|loadUInt16(){}[0]
    open fun loadUInt32(): kotlin/UInt // org.ton.cell/CellSlice.loadUInt32|loadUInt32(){}[0]
    open fun loadUInt64(): kotlin/ULong // org.ton.cell/CellSlice.loadUInt64|loadUInt64(){}[0]
    open fun loadUInt8(): kotlin/UByte // org.ton.cell/CellSlice.loadUInt8|loadUInt8(){}[0]
    open fun loadUIntLeq(kotlin/Int): org.ton.bigint/BigInt // org.ton.cell/CellSlice.loadUIntLeq|loadUIntLeq(kotlin.Int){}[0]
    open fun loadUIntLes(kotlin/Int): org.ton.bigint/BigInt // org.ton.cell/CellSlice.loadUIntLes|loadUIntLes(kotlin.Int){}[0]
    open fun loadULong(kotlin/Int = ...): kotlin/ULong // org.ton.cell/CellSlice.loadULong|loadULong(kotlin.Int){}[0]
    open fun preloadBit(): kotlin/Boolean // org.ton.cell/CellSlice.preloadBit|preloadBit(){}[0]
    open fun preloadBits(kotlin/Int): org.ton.bitstring/BitString // org.ton.cell/CellSlice.preloadBits|preloadBits(kotlin.Int){}[0]
    open fun preloadByteString(kotlin/Int): kotlinx.io.bytestring/ByteString // org.ton.cell/CellSlice.preloadByteString|preloadByteString(kotlin.Int){}[0]
    open fun preloadInt(kotlin/Int): org.ton.bigint/BigInt // org.ton.cell/CellSlice.preloadInt|preloadInt(kotlin.Int){}[0]
    open fun preloadLong(kotlin/Int = ...): kotlin/Long // org.ton.cell/CellSlice.preloadLong|preloadLong(kotlin.Int){}[0]
    open fun preloadTinyInt(kotlin/Int): kotlin/Long // org.ton.cell/CellSlice.preloadTinyInt|preloadTinyInt(kotlin.Int){}[0]
    open fun preloadUInt(kotlin/Int): org.ton.bigint/BigInt // org.ton.cell/CellSlice.preloadUInt|preloadUInt(kotlin.Int){}[0]
    open fun preloadUIntLeq(kotlin/Int): org.ton.bigint/BigInt // org.ton.cell/CellSlice.preloadUIntLeq|preloadUIntLeq(kotlin.Int){}[0]
    open fun preloadUIntLes(kotlin/Int): org.ton.bigint/BigInt // org.ton.cell/CellSlice.preloadUIntLes|preloadUIntLes(kotlin.Int){}[0]

    final object Companion { // org.ton.cell/CellSlice.Companion|null[0]
        final fun beginParse(org.ton.cell/Cell): org.ton.cell/CellSlice // org.ton.cell/CellSlice.Companion.beginParse|beginParse(org.ton.cell.Cell){}[0]
        final fun of(org.ton.bitstring/BitString, kotlin.collections/List<org.ton.cell/Cell> = ...): org.ton.cell/CellSlice // org.ton.cell/CellSlice.Companion.of|of(org.ton.bitstring.BitString;kotlin.collections.List<org.ton.cell.Cell>){}[0]
    }
}

abstract interface org.ton.kotlin.cell/CellContext { // org.ton.kotlin.cell/CellContext|null[0]
    abstract fun finalizeCell(org.ton.cell/CellBuilder): org.ton.cell/Cell // org.ton.kotlin.cell/CellContext.finalizeCell|finalizeCell(org.ton.cell.CellBuilder){}[0]
    abstract fun loadCell(org.ton.cell/Cell): org.ton.cell/DataCell // org.ton.kotlin.cell/CellContext.loadCell|loadCell(org.ton.cell.Cell){}[0]

    final object Companion { // org.ton.kotlin.cell/CellContext.Companion|null[0]
        final val EMPTY // org.ton.kotlin.cell/CellContext.Companion.EMPTY|{}EMPTY[0]
            final fun <get-EMPTY>(): org.ton.kotlin.cell/CellContext // org.ton.kotlin.cell/CellContext.Companion.EMPTY.<get-EMPTY>|<get-EMPTY>(){}[0]
    }
}

abstract interface org.ton.kotlin.cell/CellSizeable { // org.ton.kotlin.cell/CellSizeable|null[0]
    abstract val cellSize // org.ton.kotlin.cell/CellSizeable.cellSize|{}cellSize[0]
        abstract fun <get-cellSize>(): org.ton.kotlin.cell/CellSize // org.ton.kotlin.cell/CellSizeable.cellSize.<get-cellSize>|<get-cellSize>(){}[0]
}

final class org.ton.boc/CachedBagOfCells : kotlin.collections/Iterable<org.ton.cell/Cell>, org.ton.boc/BagOfCells { // org.ton.boc/CachedBagOfCells|null[0]
    constructor <init>(kotlin.collections/List<org.ton.cell/Cell>) // org.ton.boc/CachedBagOfCells.<init>|<init>(kotlin.collections.List<org.ton.cell.Cell>){}[0]

    final val roots // org.ton.boc/CachedBagOfCells.roots|{}roots[0]
        final fun <get-roots>(): kotlin.collections/List<org.ton.cell/Cell> // org.ton.boc/CachedBagOfCells.roots.<get-roots>|<get-roots>(){}[0]

    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.boc/CachedBagOfCells.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.boc/CachedBagOfCells.hashCode|hashCode(){}[0]
    final fun iterator(): kotlin.collections/Iterator<org.ton.cell/Cell> // org.ton.boc/CachedBagOfCells.iterator|iterator(){}[0]
    final fun toByteArray(): kotlin/ByteArray // org.ton.boc/CachedBagOfCells.toByteArray|toByteArray(){}[0]
    final fun toString(): kotlin/String // org.ton.boc/CachedBagOfCells.toString|toString(){}[0]

    final object Companion { // org.ton.boc/CachedBagOfCells.Companion|null[0]
        final const val MAX_CELL_WEIGHT // org.ton.boc/CachedBagOfCells.Companion.MAX_CELL_WEIGHT|{}MAX_CELL_WEIGHT[0]
            final fun <get-MAX_CELL_WEIGHT>(): kotlin/Int // org.ton.boc/CachedBagOfCells.Companion.MAX_CELL_WEIGHT.<get-MAX_CELL_WEIGHT>|<get-MAX_CELL_WEIGHT>(){}[0]
    }
}

final class org.ton.cell.exception/CellOverflowException : kotlin/RuntimeException { // org.ton.cell.exception/CellOverflowException|null[0]
    constructor <init>(kotlin/String) // org.ton.cell.exception/CellOverflowException.<init>|<init>(kotlin.String){}[0]
    constructor <init>(kotlin/String, kotlin/Throwable) // org.ton.cell.exception/CellOverflowException.<init>|<init>(kotlin.String;kotlin.Throwable){}[0]
    constructor <init>(kotlin/Throwable) // org.ton.cell.exception/CellOverflowException.<init>|<init>(kotlin.Throwable){}[0]
}

final class org.ton.cell.exception/CellUnderflowException : kotlin/RuntimeException { // org.ton.cell.exception/CellUnderflowException|null[0]
    constructor <init>(kotlin/String) // org.ton.cell.exception/CellUnderflowException.<init>|<init>(kotlin.String){}[0]
    constructor <init>(kotlin/String, kotlin/Throwable) // org.ton.cell.exception/CellUnderflowException.<init>|<init>(kotlin.String;kotlin.Throwable){}[0]
    constructor <init>(kotlin/Throwable) // org.ton.cell.exception/CellUnderflowException.<init>|<init>(kotlin.Throwable){}[0]
}

final class org.ton.cell/DataCell : org.ton.cell/Cell { // org.ton.cell/DataCell|null[0]
    constructor <init>(org.ton.cell/CellDescriptor, org.ton.bitstring/BitString, kotlin.collections/List<org.ton.cell/Cell>, kotlin.collections/List<kotlin/Pair<kotlin/ByteArray, kotlin/Int>>) // org.ton.cell/DataCell.<init>|<init>(org.ton.cell.CellDescriptor;org.ton.bitstring.BitString;kotlin.collections.List<org.ton.cell.Cell>;kotlin.collections.List<kotlin.Pair<kotlin.ByteArray,kotlin.Int>>){}[0]

    final val bits // org.ton.cell/DataCell.bits|{}bits[0]
        final fun <get-bits>(): org.ton.bitstring/BitString // org.ton.cell/DataCell.bits.<get-bits>|<get-bits>(){}[0]
    final val descriptor // org.ton.cell/DataCell.descriptor|{}descriptor[0]
        final fun <get-descriptor>(): org.ton.cell/CellDescriptor // org.ton.cell/DataCell.descriptor.<get-descriptor>|<get-descriptor>(){}[0]
    final val refs // org.ton.cell/DataCell.refs|{}refs[0]
        final fun <get-refs>(): kotlin.collections/List<org.ton.cell/Cell> // org.ton.cell/DataCell.refs.<get-refs>|<get-refs>(){}[0]

    final fun depth(kotlin/Int): kotlin/Int // org.ton.cell/DataCell.depth|depth(kotlin.Int){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.cell/DataCell.equals|equals(kotlin.Any?){}[0]
    final fun hash(kotlin/Int): org.ton.bitstring/BitString // org.ton.cell/DataCell.hash|hash(kotlin.Int){}[0]
    final fun hashCode(): kotlin/Int // org.ton.cell/DataCell.hashCode|hashCode(){}[0]
    final fun toString(): kotlin/String // org.ton.cell/DataCell.toString|toString(){}[0]
    final fun virtualize(kotlin/Int): org.ton.cell/Cell // org.ton.cell/DataCell.virtualize|virtualize(kotlin.Int){}[0]
}

final class org.ton.cell/PrunedBranchCell : org.ton.cell/Cell { // org.ton.cell/PrunedBranchCell|null[0]
    constructor <init>(org.ton.bitstring/BitString, kotlin/Int, org.ton.cell/CellDescriptor, org.ton.bitstring/BitString) // org.ton.cell/PrunedBranchCell.<init>|<init>(org.ton.bitstring.BitString;kotlin.Int;org.ton.cell.CellDescriptor;org.ton.bitstring.BitString){}[0]

    final val bits // org.ton.cell/PrunedBranchCell.bits|{}bits[0]
        final fun <get-bits>(): org.ton.bitstring/BitString // org.ton.cell/PrunedBranchCell.bits.<get-bits>|<get-bits>(){}[0]
    final val descriptor // org.ton.cell/PrunedBranchCell.descriptor|{}descriptor[0]
        final fun <get-descriptor>(): org.ton.cell/CellDescriptor // org.ton.cell/PrunedBranchCell.descriptor.<get-descriptor>|<get-descriptor>(){}[0]
    final val refs // org.ton.cell/PrunedBranchCell.refs|{}refs[0]
        final fun <get-refs>(): kotlin.collections/List<org.ton.cell/Cell> // org.ton.cell/PrunedBranchCell.refs.<get-refs>|<get-refs>(){}[0]

    final fun depth(kotlin/Int): kotlin/Int // org.ton.cell/PrunedBranchCell.depth|depth(kotlin.Int){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.cell/PrunedBranchCell.equals|equals(kotlin.Any?){}[0]
    final fun hash(kotlin/Int): org.ton.bitstring/BitString // org.ton.cell/PrunedBranchCell.hash|hash(kotlin.Int){}[0]
    final fun hashCode(): kotlin/Int // org.ton.cell/PrunedBranchCell.hashCode|hashCode(){}[0]
    final fun toString(): kotlin/String // org.ton.cell/PrunedBranchCell.toString|toString(){}[0]
    final fun virtualize(kotlin/Int): org.ton.cell/Cell // org.ton.cell/PrunedBranchCell.virtualize|virtualize(kotlin.Int){}[0]
}

final class org.ton.kotlin.cell/CellSize { // org.ton.kotlin.cell/CellSize|null[0]
    constructor <init>(kotlin/Int, kotlin/Int) // org.ton.kotlin.cell/CellSize.<init>|<init>(kotlin.Int;kotlin.Int){}[0]
    constructor <init>(kotlin/Int, kotlin/Int, kotlin/Int, kotlin/Int) // org.ton.kotlin.cell/CellSize.<init>|<init>(kotlin.Int;kotlin.Int;kotlin.Int;kotlin.Int){}[0]

    final val maxBits // org.ton.kotlin.cell/CellSize.maxBits|{}maxBits[0]
        final fun <get-maxBits>(): kotlin/Int // org.ton.kotlin.cell/CellSize.maxBits.<get-maxBits>|<get-maxBits>(){}[0]
    final val maxRefs // org.ton.kotlin.cell/CellSize.maxRefs|{}maxRefs[0]
        final fun <get-maxRefs>(): kotlin/Int // org.ton.kotlin.cell/CellSize.maxRefs.<get-maxRefs>|<get-maxRefs>(){}[0]
    final val minBits // org.ton.kotlin.cell/CellSize.minBits|{}minBits[0]
        final fun <get-minBits>(): kotlin/Int // org.ton.kotlin.cell/CellSize.minBits.<get-minBits>|<get-minBits>(){}[0]
    final val minRefs // org.ton.kotlin.cell/CellSize.minRefs|{}minRefs[0]
        final fun <get-minRefs>(): kotlin/Int // org.ton.kotlin.cell/CellSize.minRefs.<get-minRefs>|<get-minRefs>(){}[0]

    final fun fitsIntoCell(): kotlin/Boolean // org.ton.kotlin.cell/CellSize.fitsIntoCell|fitsIntoCell(){}[0]
    final fun isFixed(): kotlin/Boolean // org.ton.kotlin.cell/CellSize.isFixed|isFixed(){}[0]
    final fun plus(org.ton.kotlin.cell/CellSize): org.ton.kotlin.cell/CellSize // org.ton.kotlin.cell/CellSize.plus|plus(org.ton.kotlin.cell.CellSize){}[0]
    final fun toString(): kotlin/String // org.ton.kotlin.cell/CellSize.toString|toString(){}[0]

    final object Companion { // org.ton.kotlin.cell/CellSize.Companion|null[0]
        final val ZERO // org.ton.kotlin.cell/CellSize.Companion.ZERO|{}ZERO[0]
            final fun <get-ZERO>(): org.ton.kotlin.cell/CellSize // org.ton.kotlin.cell/CellSize.Companion.ZERO.<get-ZERO>|<get-ZERO>(){}[0]
    }
}

final value class org.ton.cell/LevelMask { // org.ton.cell/LevelMask|null[0]
    constructor <init>(kotlin/Int = ...) // org.ton.cell/LevelMask.<init>|<init>(kotlin.Int){}[0]

    final val hashCount // org.ton.cell/LevelMask.hashCount|{}hashCount[0]
        final fun <get-hashCount>(): kotlin/Int // org.ton.cell/LevelMask.hashCount.<get-hashCount>|<get-hashCount>(){}[0]
    final val hashIndex // org.ton.cell/LevelMask.hashIndex|{}hashIndex[0]
        final fun <get-hashIndex>(): kotlin/Int // org.ton.cell/LevelMask.hashIndex.<get-hashIndex>|<get-hashIndex>(){}[0]
    final val level // org.ton.cell/LevelMask.level|{}level[0]
        final fun <get-level>(): kotlin/Int // org.ton.cell/LevelMask.level.<get-level>|<get-level>(){}[0]
    final val mask // org.ton.cell/LevelMask.mask|{}mask[0]
        final fun <get-mask>(): kotlin/Int // org.ton.cell/LevelMask.mask.<get-mask>|<get-mask>(){}[0]

    final fun apply(kotlin/Int): org.ton.cell/LevelMask // org.ton.cell/LevelMask.apply|apply(kotlin.Int){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // org.ton.cell/LevelMask.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // org.ton.cell/LevelMask.hashCode|hashCode(){}[0]
    final fun isEmpty(): kotlin/Boolean // org.ton.cell/LevelMask.isEmpty|isEmpty(){}[0]
    final fun isSignificant(kotlin/Int): kotlin/Boolean // org.ton.cell/LevelMask.isSignificant|isSignificant(kotlin.Int){}[0]
    final fun or(org.ton.cell/LevelMask): org.ton.cell/LevelMask // org.ton.cell/LevelMask.or|or(org.ton.cell.LevelMask){}[0]
    final fun shr(kotlin/Int): org.ton.cell/LevelMask // org.ton.cell/LevelMask.shr|shr(kotlin.Int){}[0]
    final fun toString(): kotlin/String // org.ton.cell/LevelMask.toString|toString(){}[0]
    final fun virtualize(kotlin/Int = ...): org.ton.cell/LevelMask // org.ton.cell/LevelMask.virtualize|virtualize(kotlin.Int){}[0]

    final object Companion { // org.ton.cell/LevelMask.Companion|null[0]
        final fun level(kotlin/Int): org.ton.cell/LevelMask // org.ton.cell/LevelMask.Companion.level|level(kotlin.Int){}[0]
    }
}

final val org.ton.kotlin.cell/cellSize // org.ton.kotlin.cell/cellSize|@org.ton.kotlin.cell.CellSizeable?{}cellSize[0]
    final fun (org.ton.kotlin.cell/CellSizeable?).<get-cellSize>(): org.ton.kotlin.cell/CellSize // org.ton.kotlin.cell/cellSize.<get-cellSize>|<get-cellSize>@org.ton.kotlin.cell.CellSizeable?(){}[0]

final fun (kotlin/String).org.ton.boc/base64ToCell(): org.ton.cell/Cell // org.ton.boc/base64ToCell|base64ToCell@kotlin.String(){}[0]
final fun (org.ton.cell/CellBuilder).org.ton.cell/storeUInt(kotlin/UInt, kotlin/Int = ...): org.ton.cell/CellBuilder // org.ton.cell/storeUInt|storeUInt@org.ton.cell.CellBuilder(kotlin.UInt;kotlin.Int){}[0]
final fun org.ton.boc/BagOfCells(kotlin.collections/Collection<org.ton.cell/Cell>): org.ton.boc/BagOfCells // org.ton.boc/BagOfCells|BagOfCells(kotlin.collections.Collection<org.ton.cell.Cell>){}[0]
final fun org.ton.boc/BagOfCells(kotlin/Array<out org.ton.cell/Cell>...): org.ton.boc/BagOfCells // org.ton.boc/BagOfCells|BagOfCells(kotlin.Array<out|org.ton.cell.Cell>...){}[0]
final fun org.ton.boc/BagOfCells(kotlin/ByteArray): org.ton.boc/BagOfCells // org.ton.boc/BagOfCells|BagOfCells(kotlin.ByteArray){}[0]
final inline fun (org.ton.cell/CellBuilder).org.ton.cell/invoke(kotlin/Function1<org.ton.cell/CellBuilder, kotlin/Unit>) // org.ton.cell/invoke|invoke@org.ton.cell.CellBuilder(kotlin.Function1<org.ton.cell.CellBuilder,kotlin.Unit>){}[0]
final inline fun (org.ton.cell/CellBuilder).org.ton.cell/storeRef(org.ton.kotlin.cell/CellContext = ..., kotlin/Function1<org.ton.cell/CellBuilder, kotlin/Unit>): org.ton.cell/CellBuilder // org.ton.cell/storeRef|storeRef@org.ton.cell.CellBuilder(org.ton.kotlin.cell.CellContext;kotlin.Function1<org.ton.cell.CellBuilder,kotlin.Unit>){}[0]
final inline fun <#A: kotlin/Any?> (org.ton.cell/CellSlice).org.ton.cell/invoke(kotlin/Function1<org.ton.cell/CellSlice, #A>): #A // org.ton.cell/invoke|invoke@org.ton.cell.CellSlice(kotlin.Function1<org.ton.cell.CellSlice,0:0>){0ยง<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (org.ton.cell/CellSlice).org.ton.cell/loadRef(org.ton.kotlin.cell/CellContext = ..., kotlin/Function1<org.ton.cell/CellSlice, #A>): #A // org.ton.cell/loadRef|loadRef@org.ton.cell.CellSlice(org.ton.kotlin.cell.CellContext;kotlin.Function1<org.ton.cell.CellSlice,0:0>){0ยง<kotlin.Any?>}[0]
final inline fun org.ton.cell/Cell(): org.ton.cell/Cell // org.ton.cell/Cell|Cell(){}[0]
final inline fun org.ton.cell/Cell(kotlin/String, kotlin/Array<out org.ton.cell/Cell>...): org.ton.cell/Cell // org.ton.cell/Cell|Cell(kotlin.String;kotlin.Array<out|org.ton.cell.Cell>...){}[0]
final inline fun org.ton.cell/Cell(org.ton.bitstring/BitString, kotlin/Array<out org.ton.cell/Cell>...): org.ton.cell/Cell // org.ton.cell/Cell|Cell(org.ton.bitstring.BitString;kotlin.Array<out|org.ton.cell.Cell>...){}[0]
final inline fun org.ton.cell/CellBuilder(): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder|CellBuilder(){}[0]
final inline fun org.ton.cell/CellBuilder(org.ton.cell/Cell): org.ton.cell/CellBuilder // org.ton.cell/CellBuilder|CellBuilder(org.ton.cell.Cell){}[0]
final inline fun org.ton.cell/CellDescriptor(kotlin/Byte, kotlin/Byte): org.ton.cell/CellDescriptor // org.ton.cell/CellDescriptor|CellDescriptor(kotlin.Byte;kotlin.Byte){}[0]
final inline fun org.ton.cell/CellDescriptor(kotlin/ByteArray): org.ton.cell/CellDescriptor // org.ton.cell/CellDescriptor|CellDescriptor(kotlin.ByteArray){}[0]
final inline fun org.ton.cell/CellDescriptor(kotlin/ByteArray, kotlin/Int): org.ton.cell/CellDescriptor // org.ton.cell/CellDescriptor|CellDescriptor(kotlin.ByteArray;kotlin.Int){}[0]
final inline fun org.ton.cell/CellDescriptor(org.ton.cell/LevelMask, kotlin/Boolean, kotlin/Int, kotlin/Int): org.ton.cell/CellDescriptor // org.ton.cell/CellDescriptor|CellDescriptor(org.ton.cell.LevelMask;kotlin.Boolean;kotlin.Int;kotlin.Int){}[0]
final inline fun org.ton.cell/CellSlice(org.ton.bitstring/BitString, kotlin.collections/List<org.ton.cell/Cell> = ...): org.ton.cell/CellSlice // org.ton.cell/CellSlice|CellSlice(org.ton.bitstring.BitString;kotlin.collections.List<org.ton.cell.Cell>){}[0]
final inline fun org.ton.cell/buildCell(org.ton.kotlin.cell/CellContext = ..., kotlin/Function1<org.ton.cell/CellBuilder, kotlin/Unit>): org.ton.cell/Cell // org.ton.cell/buildCell|buildCell(org.ton.kotlin.cell.CellContext;kotlin.Function1<org.ton.cell.CellBuilder,kotlin.Unit>){}[0]
