package org.ton.kotlin.block

import kotlinx.serialization.SerialName
import org.ton.kotlin.bigint.*
import org.ton.kotlin.cell.CellBuilder
import org.ton.kotlin.cell.CellSlice
import org.ton.kotlin.cell.invoke
import org.ton.kotlin.tlb.TlbCodec
import org.ton.kotlin.tlb.TlbConstructor
import org.ton.kotlin.tlb.TlbObject
import org.ton.kotlin.tlb.TlbPrettyPrinter
import kotlin.jvm.JvmName
import kotlin.jvm.JvmStatic

@SerialName("var_uint")

public data class VarUInteger(
    @get:JvmName("len")
    val len: Int,

    @get:JvmName("value")
    val value: BigInt
) : TlbObject {
    @Deprecated("Use explicit constructor instead. In feature TLB classes will be auto-generated by TLB parser")
    public constructor(int: Int) : this(int.toBigInt())

    @Deprecated("Use explicit constructor instead. In feature TLB classes will be auto-generated by TLB parser")
    public constructor(long: Long) : this(long.toBigInt())

    @Deprecated("Use explicit constructor instead. In feature TLB classes will be auto-generated by TLB parser")
    public constructor(value: BigInt) : this(
        len = value.bitLength / Byte.SIZE_BITS + if (value.bitLength % Byte.SIZE_BITS == 0) 0 else 1,
        value = value
    )

    @Deprecated("Use VarUInteger.value instead")
    public fun toByte(): Byte = value.toByte()

    @Deprecated("Use VarUInteger.value instead")
    public fun toChar(): Char = value.toChar()

    @Deprecated("Use VarUInteger.value instead")
    public fun toDouble(): Double = throw UnsupportedOperationException()

    @Deprecated("Use VarUInteger.value instead")
    public fun toFloat(): Float = throw UnsupportedOperationException()

    @Deprecated("Use VarUInteger.value instead")
    public fun toInt(): Int = value.toInt()

    @Deprecated("Use VarUInteger.value instead")
    public fun toLong(): Long = value.toLong()

    @Deprecated("Use VarUInteger.value instead")
    public fun toShort(): Short = value.toShort()

    @Deprecated("Use VarUInteger.value instead")
    public operator fun plus(other: VarUInteger): VarUInteger {
        val result = value + other.value
        val maxLen = maxOf(len, other.len)
        val actualLen = result.bitLength
        val length = if (actualLen <= maxLen) maxLen else throw NumberFormatException("Integer overflow")
        return VarUInteger(length, result)
    }

    @Deprecated("Use VarUInteger.value instead")
    public operator fun minus(other: VarUInteger): VarUInteger {
        val result = value - other.value
        if (result < 0L) throw NumberFormatException("Integer underflow")
        val len = maxOf(len, other.len)
        return VarUInteger(len, result)
    }

    @Deprecated("Use VarUInteger.value instead")
    public operator fun times(other: VarUInteger): VarUInteger {
        val result = value * other.value
        val maxLen = maxOf(len, other.len)
        val actualLen = result.bitLength
        val len = if (actualLen <= maxLen) maxLen else throw NumberFormatException("Integer overflow")
        return VarUInteger(len, result)
    }

    @Deprecated("Use VarUInteger.value instead")
    public operator fun div(other: VarUInteger): VarUInteger {
        val result = value / other.value
        val maxLen = maxOf(len, other.len)
        val actualLen = result.bitLength
        val len = if (actualLen <= maxLen) maxLen else throw NumberFormatException("Integer overflow")
        return VarUInteger(len, result)
    }

    @Deprecated("Use VarUInteger.value instead")
    public operator fun rem(other: VarUInteger): VarUInteger {
        val result = value % other.value
        val maxLen = maxOf(len, other.len)
        val actualLen = result.bitLength
        val len = if (actualLen <= maxLen) maxLen else throw NumberFormatException("Integer overflow")
        return VarUInteger(len, result)
    }

    @Deprecated("Use VarUInteger.value instead")
    public operator fun inc(): VarUInteger {
        val result = value + 1.toBigInt()
        val actualLen = result.bitLength
        val length = if (actualLen < len) len else throw NumberFormatException("Integer overflow")
        return VarUInteger(length, result)
    }

    @Deprecated("Use VarUInteger.value instead")
    public operator fun dec(): VarUInteger {
        val result = value - 1.toBigInt()
        if (result < 0.toBigInt()) throw NumberFormatException("Integer overflow")
        return VarUInteger(len, result)
    }

    override fun print(printer: TlbPrettyPrinter): TlbPrettyPrinter {
        return printer.type("var_uint") {
            field("len", len)
            field("value", value)
        }
    }

    override fun toString(): String = value.toString()

    public companion object {
        public val VAR_U_INTEGER_3: TlbCodec<VarUInteger> = VarUIntegerTlbConstructor(3)
        public val VAR_U_INTEGER_7: TlbCodec<VarUInteger> = VarUIntegerTlbConstructor(7)
        public val VAR_U_INTEGER_16: TlbCodec<VarUInteger> = VarUIntegerTlbConstructor(16)

        @JvmStatic
        public fun tlbCodec(n: Int): TlbCodec<VarUInteger> = when (n) {
            3 -> VAR_U_INTEGER_3
            7 -> VAR_U_INTEGER_7
            16 -> VAR_U_INTEGER_16
            else -> VarUIntegerTlbConstructor(n)
        }
    }

    private class VarUIntegerTlbConstructor(
        val n: Int
    ) : TlbConstructor<VarUInteger>(
        schema = "var_uint\$_ {n:#} len:(#< n) value:(uint (len * 8)) = VarUInteger n;"
    ) {
        override fun storeTlb(
            cellBuilder: CellBuilder, value: VarUInteger
        ) = cellBuilder {
            storeUIntLes(value.len, n)
            storeUInt(value.value, value.len * 8)
        }

        override fun loadTlb(
            cellSlice: CellSlice
        ): VarUInteger = cellSlice {
            val len = loadUIntLes(n).toInt()
            val value = loadUInt(len * 8)
            VarUInteger(len, value)
        }
    }
}
